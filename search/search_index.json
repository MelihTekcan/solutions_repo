{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile motion is a fundamental concept in physics that describes the motion of an object launched into the air under the influence of gravity. This motion is characterized by a parabolic trajectory , and it is widely applicable in sports, engineering, and astrophysics. 1. Theoretical Foundation What is Projectile Motion? Projectile motion occurs when an object is launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) to the horizontal. The motion is influenced only by gravity \\(g\\) , assuming no air resistance. The motion can be broken into two independent components: Horizontal Motion : The horizontal velocity remains constant because there is no horizontal acceleration. The horizontal position at time \\(t\\) is given by: $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical Motion : The vertical velocity decreases due to the acceleration caused by gravity. The vertical position at time \\(t\\) is given by: $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ Key Equations Time of Flight : The total time the projectile spends in the air is: $$ T = \\frac{2 v_0 \\sin(\\theta)}{g} $$ Range : The horizontal distance traveled by the projectile is: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ Maximum Height : The highest point reached by the projectile is: $$ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} $$ 2. Analysis of the Range How Does the Range Depend on the Angle of Projection? TThe range \\(R\\) depends on: Initial velocity ( \\(v_0\\) ) Quadratic dependence: $$ R \\propto v_0^2 $$ Projection angle ( \\(\\theta\\) ) Maximum at \\(45^\\circ\\) : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ Gravity ( \\(g\\) ) Inversely proportional: $$ R \\propto \\frac{1}{g} $$ Key Observations The range is symmetric: $$ R(\\theta) = R(90^\\circ - \\theta) $$ For example, the range at \\(\\theta = 30^\\circ\\) is the same as at \\(\\theta = 60^\\circ\\) . The maximum range occurs at \\(\\theta = 45^\\circ\\) for flat terrain. 3. Practical Applications Real-World Scenarios Projectile motion has numerous real-world applications across various fields: Sports : In sports like soccer and golf, players adjust the angle of projection ( \\(\\theta\\) ) and the initial velocity ( \\(v_0\\) ) to achieve optimal range or height. For example: A soccer player might aim for a higher angle to clear a wall of defenders. A golfer adjusts the angle and velocity to maximize the distance of a drive. Engineering : Engineers use projectile motion principles to design artillery and rockets. They account for factors like terrain, wind effects, and the desired range to ensure accuracy. For example: Artillery shells are launched at specific angles to hit targets at known distances. Rockets are launched with precise trajectories to reach their destinations. Astrophysics : In space exploration, spacecraft trajectories are calculated using projectile motion principles. However, these calculations also account for variable gravitational forces and drag. For example: A Mars rover's landing trajectory is carefully planned to ensure a safe descent. Satellites are launched into orbit using similar principles, with adjustments for Earth's curvature and atmosphere. Trajectory Example The trajectory for an object launched with an initial velocity of \\(v_0 = 20\\,\\text{m/s}\\) at an angle of \\(\\theta = 45^\\circ\\) The parabolic path demonstrates the interplay between horizontal and vertical motion: - The horizontal motion is uniform, with a constant velocity. - The vertical motion is accelerated due to gravity, resulting in a curved path. 4. Implementation import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.8 # Acceleration due to gravity (m/s^2) v0_values = [10, 20, 30] # Initial velocities (m/s) theta_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 theta_rad = np.deg2rad(theta_deg) # Range function def range_projectile(v0, theta, g): return (v0**2 * np.sin(2 * theta)) / g # Compute ranges for different initial velocities ranges = {v0: range_projectile(v0, theta_rad, g) for v0 in v0_values} # Plot Range vs Angle plt.figure(figsize=(10, 6)) for v0, R in ranges.items(): plt.plot(theta_deg, R, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show() # Trajectory for v0 = 20 m/s and \u03b8 = 45\u00b0 v0 = 20 # Initial velocity (m/s) theta = np.deg2rad(45) # Launch angle (radians) t_flight = (2 * v0 * np.sin(theta)) / g # Total flight time t = np.linspace(0, t_flight, 100) # Time intervals # Compute trajectory x = v0 * np.cos(theta) * t # Horizontal position y = v0 * np.sin(theta) * t - 0.5 * g * t**2 # Vertical position # Plot trajectory plt.figure(figsize=(10, 6)) plt.plot(x, y, label='Trajectory (v0 = 20 m/s, \u03b8 = 45\u00b0)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Trajectory') plt.legend() plt.grid(True) plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Projectile motion is a fundamental concept in physics that describes the motion of an object launched into the air under the influence of gravity. This motion is characterized by a parabolic trajectory , and it is widely applicable in sports, engineering, and astrophysics.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#what-is-projectile-motion","text":"Projectile motion occurs when an object is launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) to the horizontal. The motion is influenced only by gravity \\(g\\) , assuming no air resistance. The motion can be broken into two independent components: Horizontal Motion : The horizontal velocity remains constant because there is no horizontal acceleration. The horizontal position at time \\(t\\) is given by: $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical Motion : The vertical velocity decreases due to the acceleration caused by gravity. The vertical position at time \\(t\\) is given by: $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$","title":"What is Projectile Motion?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-equations","text":"Time of Flight : The total time the projectile spends in the air is: $$ T = \\frac{2 v_0 \\sin(\\theta)}{g} $$ Range : The horizontal distance traveled by the projectile is: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ Maximum Height : The highest point reached by the projectile is: $$ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} $$","title":"Key Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#how-does-the-range-depend-on-the-angle-of-projection","text":"TThe range \\(R\\) depends on: Initial velocity ( \\(v_0\\) ) Quadratic dependence: $$ R \\propto v_0^2 $$ Projection angle ( \\(\\theta\\) ) Maximum at \\(45^\\circ\\) : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ Gravity ( \\(g\\) ) Inversely proportional: $$ R \\propto \\frac{1}{g} $$","title":"How Does the Range Depend on the Angle of Projection?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"The range is symmetric: $$ R(\\theta) = R(90^\\circ - \\theta) $$ For example, the range at \\(\\theta = 30^\\circ\\) is the same as at \\(\\theta = 60^\\circ\\) . The maximum range occurs at \\(\\theta = 45^\\circ\\) for flat terrain.","title":"Key Observations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#real-world-scenarios","text":"Projectile motion has numerous real-world applications across various fields: Sports : In sports like soccer and golf, players adjust the angle of projection ( \\(\\theta\\) ) and the initial velocity ( \\(v_0\\) ) to achieve optimal range or height. For example: A soccer player might aim for a higher angle to clear a wall of defenders. A golfer adjusts the angle and velocity to maximize the distance of a drive. Engineering : Engineers use projectile motion principles to design artillery and rockets. They account for factors like terrain, wind effects, and the desired range to ensure accuracy. For example: Artillery shells are launched at specific angles to hit targets at known distances. Rockets are launched with precise trajectories to reach their destinations. Astrophysics : In space exploration, spacecraft trajectories are calculated using projectile motion principles. However, these calculations also account for variable gravitational forces and drag. For example: A Mars rover's landing trajectory is carefully planned to ensure a safe descent. Satellites are launched into orbit using similar principles, with adjustments for Earth's curvature and atmosphere.","title":"Real-World Scenarios"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#trajectory-example","text":"The trajectory for an object launched with an initial velocity of \\(v_0 = 20\\,\\text{m/s}\\) at an angle of \\(\\theta = 45^\\circ\\) The parabolic path demonstrates the interplay between horizontal and vertical motion: - The horizontal motion is uniform, with a constant velocity. - The vertical motion is accelerated due to gravity, resulting in a curved path.","title":"Trajectory Example"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.8 # Acceleration due to gravity (m/s^2) v0_values = [10, 20, 30] # Initial velocities (m/s) theta_deg = np.linspace(0, 90, 91) # Angles from 0\u00b0 to 90\u00b0 theta_rad = np.deg2rad(theta_deg) # Range function def range_projectile(v0, theta, g): return (v0**2 * np.sin(2 * theta)) / g # Compute ranges for different initial velocities ranges = {v0: range_projectile(v0, theta_rad, g) for v0 in v0_values} # Plot Range vs Angle plt.figure(figsize=(10, 6)) for v0, R in ranges.items(): plt.plot(theta_deg, R, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show() # Trajectory for v0 = 20 m/s and \u03b8 = 45\u00b0 v0 = 20 # Initial velocity (m/s) theta = np.deg2rad(45) # Launch angle (radians) t_flight = (2 * v0 * np.sin(theta)) / g # Total flight time t = np.linspace(0, t_flight, 100) # Time intervals # Compute trajectory x = v0 * np.cos(theta) * t # Horizontal position y = v0 * np.sin(theta) * t - 0.5 * g * t**2 # Vertical position # Plot trajectory plt.figure(figsize=(10, 6)) plt.plot(x, y, label='Trajectory (v0 = 20 m/s, \u03b8 = 45\u00b0)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Trajectory') plt.legend() plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Introduction A forced damped pendulum is a fascinating physical system that reveals how simple components\u2014like a swinging weight\u2014can produce complex behaviors. Imagine a playground swing: left alone, it slows down due to air resistance (damping); push it rhythmically, and it keeps going (forcing). This interplay creates a rich mix of motion, from smooth swings to wild, unpredictable chaos. In this document, we\u2019ll: Break down the physics step-by-step. Simulate the motion with Python. Explore real-world applications. This system is key in fields like engineering (e.g., designing stable bridges) and science (e.g., modeling climate oscillations). 2. Theoretical Foundation The heart of this system is its equation of motion, which describes how the pendulum\u2019s angle changes over time. 2.1. The Differential Equation The motion is governed by: \\[ \\frac{d^2\\theta}{dt^2} + \\frac{b}{m} \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Here\u2019s what each term means: \\(\\theta\\) : Angle from vertical (in radians\u2014e.g., 0 is straight down, \\(\\pi/2\\) is horizontal). \\(\\frac{d^2\\theta}{dt^2}\\) : Angular acceleration\u2014how fast the swinging speeds up or slows down. \\(\\frac{b}{m} \\frac{d\\theta}{dt}\\) : Damping force\u2014friction proportional to speed ( \\(\\frac{d\\theta}{dt}\\) is angular velocity). \\(\\frac{g}{L} \\sin(\\theta)\\) : Restoring force\u2014gravity pulling the pendulum back ( \\(g = 9.81 \\, \\text{m/s}^2\\) , \\(L\\) = length). \\(A \\cos(\\omega t)\\) : External forcing\u2014 \\(A\\) is the push strength, \\(\\omega\\) is the push frequency. This equation is nonlinear because of \\(\\sin(\\theta)\\) , meaning exact solutions are tough. It\u2019s like a recipe with a tricky ingredient! 2.2. Small-Angle Approximation For small swings (e.g., \\(\\theta < 0.1\\) radians, about 6\u00b0), \\(\\sin(\\theta) \\approx \\theta\\) . This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\frac{b}{m} \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a linear equation, like a spring\u2019s motion, and we can solve it. The solution has two parts: Transient : Natural oscillations (frequency \\(\\sqrt{\\frac{g}{L}}\\) ) that fade due to damping. Steady-State : Oscillations matching the forcing frequency ( \\(\\omega\\) ). Example : If \\(L = 1\\) m, the natural frequency is \\(\\sqrt{9.81} \\approx 3.13\\) rad/s. Push at this rate, and you get resonance \u2014big swings! 2.3. Resonance Resonance occurs when \\(\\omega \\approx \\sqrt{\\frac{g}{L}}\\) . The forcing adds energy perfectly in sync with the pendulum\u2019s natural rhythm, amplifying swings. Think of pushing a child on a swing: time it right, and they soar; time it wrong, and they barely move. 3. Analysis of Dynamics Let\u2019s explore how parameters shape the pendulum\u2019s dance. 3.1. Damping Coefficient ( \\(b/m\\) ) Low Damping (e.g., \\(b/m = 0.1\\) ) : Swings last longer, fading slowly. High Damping (e.g., \\(b/m = 2.0\\) ) : Motion stops quickly unless forcing is strong. Analogy : Swing in air (low damping) vs. mud (high damping). 3.2. Forcing Amplitude ( \\(A\\) ) Small \\(A\\) (e.g., 0.5) : Gentle pushes\u2014small, steady swings. Large \\(A\\) (e.g., 5.0) : Big pushes\u2014wild swings or chaos if damping can\u2019t balance it. Example : A light tap vs. a hard shove on a swing. 3.3. Forcing Frequency ( \\(\\omega\\) ) Low \\(\\omega\\) (e.g., 0.5) : Slow pushes\u2014pendulum struggles to follow. Near \\(\\sqrt{\\frac{g}{L}}\\) : Resonance\u2014huge swings. High \\(\\omega\\) (e.g., 10) : Fast jiggles\u2014small, erratic motion. 3.4. Regular vs. Chaotic Motion Regular : Predictable swings (e.g., small \\(A\\) , \\(\\omega\\) near natural frequency). Chaotic : Unpredictable wiggles (e.g., large \\(A\\) , mismatched \\(\\omega\\) ). Chaos means tiny changes (like a 0.01 radian nudge) lead to totally different paths. Test : With \\(A = 5\\) , \\(\\omega = 1.5\\) , chaos emerges\u2014see it below! 4. Practical Applications This model isn\u2019t just theoretical\u2014it\u2019s everywhere: Energy Harvesting : Tiny pendulums in watches or sensors convert motion (e.g., walking) into power. Seismic Isolation : Buildings use damped oscillators to absorb earthquake shakes. Mechanical Resonance : Engineers avoid resonance in bridges (e.g., Tacoma Narrows collapse) or exploit it in musical instruments. Real Example : The Millennium Bridge in London swayed due to crowd footsteps\u2014a forced oscillation problem! Regular Motion Simulation Here\u2019s the simulation with moderate forcing ( \\(A = 1.2\\) ): import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, b, m, g, L, A, omega_f): theta, omega_dot = y # y[0] = theta, y[1] = angular velocity dtheta_dt = omega_dot domega_dt = -(b/m) * omega_dot - (g/L) * np.sin(theta) + (A/m) * np.cos(omega_f * t) return [dtheta_dt, domega_dt] # Parameters m = 1.0 # Mass (kg) b = 0.5 # Damping coefficient g = 9.81 # Gravity (m/s\u00b2) L = 1.0 # Length of pendulum (m) A = 1.2 # Forcing amplitude omega_f = 1.5 # Forcing frequency y0 = [np.pi / 4, 0] # Initial angle = 45\u00b0, initial angular velocity = 0 # Time setup t_span = (0, 20) # Simulate for 20 seconds t_eval = np.linspace(*t_span, 1000) # Time points for evaluation # Solve the differential equation sol = solve_ivp( forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, m, g, L, A, omega_f) ) # Plotting the results plt.figure(figsize=(12, 8)) # Time series plot (angle vs. time) plt.subplot(2, 1, 1) plt.plot(sol.t, sol.y[0], label=\"Angle (\u03b8)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.title(\"Regular Motion of a Forced Damped Pendulum (A = 1.2)\") plt.legend() plt.grid(True) # Phase diagram (angle vs. angular velocity) plt.subplot(2, 1, 2) plt.plot(sol.y[0], sol.y[1]) plt.xlabel(\"Angle (\u03b8)\") plt.ylabel(\"Angular Velocity (\u03c9)\") plt.title(\"Phase Diagram\") plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-introduction","text":"A forced damped pendulum is a fascinating physical system that reveals how simple components\u2014like a swinging weight\u2014can produce complex behaviors. Imagine a playground swing: left alone, it slows down due to air resistance (damping); push it rhythmically, and it keeps going (forcing). This interplay creates a rich mix of motion, from smooth swings to wild, unpredictable chaos. In this document, we\u2019ll: Break down the physics step-by-step. Simulate the motion with Python. Explore real-world applications. This system is key in fields like engineering (e.g., designing stable bridges) and science (e.g., modeling climate oscillations).","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-theoretical-foundation","text":"The heart of this system is its equation of motion, which describes how the pendulum\u2019s angle changes over time.","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-the-differential-equation","text":"The motion is governed by: \\[ \\frac{d^2\\theta}{dt^2} + \\frac{b}{m} \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Here\u2019s what each term means: \\(\\theta\\) : Angle from vertical (in radians\u2014e.g., 0 is straight down, \\(\\pi/2\\) is horizontal). \\(\\frac{d^2\\theta}{dt^2}\\) : Angular acceleration\u2014how fast the swinging speeds up or slows down. \\(\\frac{b}{m} \\frac{d\\theta}{dt}\\) : Damping force\u2014friction proportional to speed ( \\(\\frac{d\\theta}{dt}\\) is angular velocity). \\(\\frac{g}{L} \\sin(\\theta)\\) : Restoring force\u2014gravity pulling the pendulum back ( \\(g = 9.81 \\, \\text{m/s}^2\\) , \\(L\\) = length). \\(A \\cos(\\omega t)\\) : External forcing\u2014 \\(A\\) is the push strength, \\(\\omega\\) is the push frequency. This equation is nonlinear because of \\(\\sin(\\theta)\\) , meaning exact solutions are tough. It\u2019s like a recipe with a tricky ingredient!","title":"2.1. The Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-small-angle-approximation","text":"For small swings (e.g., \\(\\theta < 0.1\\) radians, about 6\u00b0), \\(\\sin(\\theta) \\approx \\theta\\) . This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\frac{b}{m} \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a linear equation, like a spring\u2019s motion, and we can solve it. The solution has two parts: Transient : Natural oscillations (frequency \\(\\sqrt{\\frac{g}{L}}\\) ) that fade due to damping. Steady-State : Oscillations matching the forcing frequency ( \\(\\omega\\) ). Example : If \\(L = 1\\) m, the natural frequency is \\(\\sqrt{9.81} \\approx 3.13\\) rad/s. Push at this rate, and you get resonance \u2014big swings!","title":"2.2. Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#23-resonance","text":"Resonance occurs when \\(\\omega \\approx \\sqrt{\\frac{g}{L}}\\) . The forcing adds energy perfectly in sync with the pendulum\u2019s natural rhythm, amplifying swings. Think of pushing a child on a swing: time it right, and they soar; time it wrong, and they barely move.","title":"2.3. Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-analysis-of-dynamics","text":"Let\u2019s explore how parameters shape the pendulum\u2019s dance.","title":"3. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#31-damping-coefficient-bm","text":"Low Damping (e.g., \\(b/m = 0.1\\) ) : Swings last longer, fading slowly. High Damping (e.g., \\(b/m = 2.0\\) ) : Motion stops quickly unless forcing is strong. Analogy : Swing in air (low damping) vs. mud (high damping).","title":"3.1. Damping Coefficient (\\(b/m\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#32-forcing-amplitude-a","text":"Small \\(A\\) (e.g., 0.5) : Gentle pushes\u2014small, steady swings. Large \\(A\\) (e.g., 5.0) : Big pushes\u2014wild swings or chaos if damping can\u2019t balance it. Example : A light tap vs. a hard shove on a swing.","title":"3.2. Forcing Amplitude (\\(A\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#33-forcing-frequency-omega","text":"Low \\(\\omega\\) (e.g., 0.5) : Slow pushes\u2014pendulum struggles to follow. Near \\(\\sqrt{\\frac{g}{L}}\\) : Resonance\u2014huge swings. High \\(\\omega\\) (e.g., 10) : Fast jiggles\u2014small, erratic motion.","title":"3.3. Forcing Frequency (\\(\\omega\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#34-regular-vs-chaotic-motion","text":"Regular : Predictable swings (e.g., small \\(A\\) , \\(\\omega\\) near natural frequency). Chaotic : Unpredictable wiggles (e.g., large \\(A\\) , mismatched \\(\\omega\\) ). Chaos means tiny changes (like a 0.01 radian nudge) lead to totally different paths. Test : With \\(A = 5\\) , \\(\\omega = 1.5\\) , chaos emerges\u2014see it below!","title":"3.4. Regular vs. Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-practical-applications","text":"This model isn\u2019t just theoretical\u2014it\u2019s everywhere: Energy Harvesting : Tiny pendulums in watches or sensors convert motion (e.g., walking) into power. Seismic Isolation : Buildings use damped oscillators to absorb earthquake shakes. Mechanical Resonance : Engineers avoid resonance in bridges (e.g., Tacoma Narrows collapse) or exploit it in musical instruments. Real Example : The Millennium Bridge in London swayed due to crowd footsteps\u2014a forced oscillation problem!","title":"4. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular-motion-simulation","text":"Here\u2019s the simulation with moderate forcing ( \\(A = 1.2\\) ): import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, b, m, g, L, A, omega_f): theta, omega_dot = y # y[0] = theta, y[1] = angular velocity dtheta_dt = omega_dot domega_dt = -(b/m) * omega_dot - (g/L) * np.sin(theta) + (A/m) * np.cos(omega_f * t) return [dtheta_dt, domega_dt] # Parameters m = 1.0 # Mass (kg) b = 0.5 # Damping coefficient g = 9.81 # Gravity (m/s\u00b2) L = 1.0 # Length of pendulum (m) A = 1.2 # Forcing amplitude omega_f = 1.5 # Forcing frequency y0 = [np.pi / 4, 0] # Initial angle = 45\u00b0, initial angular velocity = 0 # Time setup t_span = (0, 20) # Simulate for 20 seconds t_eval = np.linspace(*t_span, 1000) # Time points for evaluation # Solve the differential equation sol = solve_ivp( forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, m, g, L, A, omega_f) ) # Plotting the results plt.figure(figsize=(12, 8)) # Time series plot (angle vs. time) plt.subplot(2, 1, 1) plt.plot(sol.t, sol.y[0], label=\"Angle (\u03b8)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.title(\"Regular Motion of a Forced Damped Pendulum (A = 1.2)\") plt.legend() plt.grid(True) # Phase diagram (angle vs. angular velocity) plt.subplot(2, 1, 2) plt.plot(sol.y[0], sol.y[1]) plt.xlabel(\"Angle (\u03b8)\") plt.ylabel(\"Angular Velocity (\u03c9)\") plt.title(\"Phase Diagram\") plt.grid(True) plt.tight_layout() plt.show()","title":"Regular Motion Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 1. Introduction Kepler's Third Law is one of the most important principles in celestial mechanics. It describes the relationship between the orbital period of a planet (or satellite) and its orbital radius. This law is fundamental for understanding planetary motion, satellite dynamics, and even exoplanet detection. What Does Kepler's Third Law State? Kepler's Third Law states: \"The square of the orbital period (T\u00b2) is proportional to the cube of the orbital radius (R\u00b3).\" This means that if you know the distance of a planet or satellite from the central body (e.g., the Sun or Earth), you can calculate how long it takes to complete one orbit. Conversely, if you know the orbital period, you can determine the orbital radius. 2. Physical Derivation: Kepler's Third Law 2.1 Basic Assumptions To derive Kepler's Third Law, we make the following assumptions: 1. Circular Orbit : The planet or satellite moves in a perfect circular orbit around the central body. 2. Centripetal Force : The gravitational force acts as the centripetal force that keeps the planet or satellite in orbit. 2.2 Mathematical Derivation Step 1: Balance Gravitational and Centripetal Forces The gravitational force between two masses is given by Newton's Law of Gravitation: \\[ F_{\\text{grav}} = G \\frac{M m}{R^2} \\] The centripetal force required to keep the planet in circular motion is: \\[ F_{\\text{centripetal}} = m \\frac{v^2}{R} \\] For a stable circular orbit, these two forces must balance: \\[ F_{\\text{grav}} = F_{\\text{centripetal}} \\] Substituting the expressions: \\[ G \\frac{M m}{R^2} = m \\frac{v^2}{R} \\] Step 2: Relate Orbital Velocity to Period The orbital velocity \\( \\(v\\) \\) is related to the orbital period \\( \\(T\\) \\) by the formula: \\[ v = \\frac{\\text{Circumference}}{\\text{Period}} = \\frac{2 \\pi R}{T} \\] Substitute this into the force balance equation: \\[ G \\frac{M}{R^2} = \\frac{\\left( \\frac{2 \\pi R}{T} \\right)^2}{R} \\] Step 3: Simplify the Expression Simplify the equation: \\[ G M = \\frac{4 \\pi^2 R^3}{T^2} \\] Rearranging for \\(T^2\\) : \\[ T^2 = \\frac{4 \\pi^2}{G M} R^3 \\] This is the mathematical expression of Kepler's Third Law . The term \\(\\frac{4 \\pi^2}{G M}\\) is a constant for a given central body (e.g., the Sun or Earth). 2.3 Key Insight Kepler's Third Law shows that: - The orbital period \\(T\\) increases with the orbital radius \\(R\\) . - Larger orbits take longer to complete because the planet or satellite must travel a greater distance at a slower speed. 3. Astronomical Significance and Applications 3.1 Calculating Planetary Masses Kepler's Third Law allows us to calculate the mass of a central body (e.g., the Sun or Earth) if we know the orbital period and radius of a planet or satellite. Example: Calculating the Sun's Mass Using Earth's orbital period (1 year) and radius (1 AU): \\[ M_{\\text{Sun}} = \\frac{4 \\pi^2 (1 \\, \\text{AU})^3}{G (1 \\, \\text{year})^2} \\] Substitute: - \\( \\(1 \\, \\text{AU} = 1.496 \\times 10^{11} \\, \\text{m}\\) \\) - \\( \\(1 \\, \\text{year} = 3.154 \\times 10^7 \\, \\text{s}\\) \\) - \\( \\(G = 6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) \\) The Sun's mass is approximately \\(1.989 \\times 10^{30} \\, \\text{kg}\\) . 3.2 Satellite Orbits Kepler's Third Law is used to calculate the orbital period of satellites around Earth. For example: - The Moon's orbital period (27.3 days) and radius (384,400 km) can be used to calculate Earth's mass. 3.3 Exoplanet Research Astronomers use Kepler's Third Law to detect and study exoplanets. By measuring the orbital period and velocity of a star (using Doppler spectroscopy), they can estimate the orbital radius and mass of the exoplanet. 4. Computational Modeling: Python Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth's mass (kg) # Orbital radii (from 1e6 m to 1e7 m) R = np.linspace(1e6, 1e7, 100) # Calculate orbital period (T) using Kepler's Third Law T = np.sqrt((4 * np.pi**2 * R**3) / (G * M)) # Plot T^2 vs R^3 plt.figure(figsize=(10, 6)) plt.plot(R**3, T**2, 'b-', label='Simulation Data') plt.xlabel('Orbital Radius Cubed (R\u00b3) [m\u00b3]') plt.ylabel('Orbital Period Squared (T\u00b2) [s\u00b2]') plt.title('Verification of Kepler\\'s Third Law') plt.grid(True) plt.legend() plt.show() 5. Results and Observations 5.1 Simulation Results The plot of \\(T^2\\) vs \\(R^3\\) shows a straight line, confirming the proportionality predicted by Kepler's Third Law. This verifies that the square of the orbital period is directly proportional to the cube of the orbital radius. 5.2 Key Takeaways Kepler's Third Law applies universally to any object in a circular orbit, whether it's a planet, satellite, or exoplanet. The relationship \\(T^2 \\propto R^3\\) allows us to calculate unknown masses or orbital parameters in astrophysical systems.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-introduction","text":"Kepler's Third Law is one of the most important principles in celestial mechanics. It describes the relationship between the orbital period of a planet (or satellite) and its orbital radius. This law is fundamental for understanding planetary motion, satellite dynamics, and even exoplanet detection.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#what-does-keplers-third-law-state","text":"Kepler's Third Law states: \"The square of the orbital period (T\u00b2) is proportional to the cube of the orbital radius (R\u00b3).\" This means that if you know the distance of a planet or satellite from the central body (e.g., the Sun or Earth), you can calculate how long it takes to complete one orbit. Conversely, if you know the orbital period, you can determine the orbital radius.","title":"What Does Kepler's Third Law State?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-physical-derivation-keplers-third-law","text":"","title":"2. Physical Derivation: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#21-basic-assumptions","text":"To derive Kepler's Third Law, we make the following assumptions: 1. Circular Orbit : The planet or satellite moves in a perfect circular orbit around the central body. 2. Centripetal Force : The gravitational force acts as the centripetal force that keeps the planet or satellite in orbit.","title":"2.1 Basic Assumptions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#22-mathematical-derivation","text":"","title":"2.2 Mathematical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-1-balance-gravitational-and-centripetal-forces","text":"The gravitational force between two masses is given by Newton's Law of Gravitation: \\[ F_{\\text{grav}} = G \\frac{M m}{R^2} \\] The centripetal force required to keep the planet in circular motion is: \\[ F_{\\text{centripetal}} = m \\frac{v^2}{R} \\] For a stable circular orbit, these two forces must balance: \\[ F_{\\text{grav}} = F_{\\text{centripetal}} \\] Substituting the expressions: \\[ G \\frac{M m}{R^2} = m \\frac{v^2}{R} \\]","title":"Step 1: Balance Gravitational and Centripetal Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-2-relate-orbital-velocity-to-period","text":"The orbital velocity \\( \\(v\\) \\) is related to the orbital period \\( \\(T\\) \\) by the formula: \\[ v = \\frac{\\text{Circumference}}{\\text{Period}} = \\frac{2 \\pi R}{T} \\] Substitute this into the force balance equation: \\[ G \\frac{M}{R^2} = \\frac{\\left( \\frac{2 \\pi R}{T} \\right)^2}{R} \\]","title":"Step 2: Relate Orbital Velocity to Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-3-simplify-the-expression","text":"Simplify the equation: \\[ G M = \\frac{4 \\pi^2 R^3}{T^2} \\] Rearranging for \\(T^2\\) : \\[ T^2 = \\frac{4 \\pi^2}{G M} R^3 \\] This is the mathematical expression of Kepler's Third Law . The term \\(\\frac{4 \\pi^2}{G M}\\) is a constant for a given central body (e.g., the Sun or Earth).","title":"Step 3: Simplify the Expression"},{"location":"1%20Physics/2%20Gravity/Problem_1/#23-key-insight","text":"Kepler's Third Law shows that: - The orbital period \\(T\\) increases with the orbital radius \\(R\\) . - Larger orbits take longer to complete because the planet or satellite must travel a greater distance at a slower speed.","title":"2.3 Key Insight"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-astronomical-significance-and-applications","text":"","title":"3. Astronomical Significance and Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#31-calculating-planetary-masses","text":"Kepler's Third Law allows us to calculate the mass of a central body (e.g., the Sun or Earth) if we know the orbital period and radius of a planet or satellite.","title":"3.1 Calculating Planetary Masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-calculating-the-suns-mass","text":"Using Earth's orbital period (1 year) and radius (1 AU): \\[ M_{\\text{Sun}} = \\frac{4 \\pi^2 (1 \\, \\text{AU})^3}{G (1 \\, \\text{year})^2} \\] Substitute: - \\( \\(1 \\, \\text{AU} = 1.496 \\times 10^{11} \\, \\text{m}\\) \\) - \\( \\(1 \\, \\text{year} = 3.154 \\times 10^7 \\, \\text{s}\\) \\) - \\( \\(G = 6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) \\) The Sun's mass is approximately \\(1.989 \\times 10^{30} \\, \\text{kg}\\) .","title":"Example: Calculating the Sun's Mass"},{"location":"1%20Physics/2%20Gravity/Problem_1/#32-satellite-orbits","text":"Kepler's Third Law is used to calculate the orbital period of satellites around Earth. For example: - The Moon's orbital period (27.3 days) and radius (384,400 km) can be used to calculate Earth's mass.","title":"3.2 Satellite Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#33-exoplanet-research","text":"Astronomers use Kepler's Third Law to detect and study exoplanets. By measuring the orbital period and velocity of a star (using Doppler spectroscopy), they can estimate the orbital radius and mass of the exoplanet.","title":"3.3 Exoplanet Research"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-computational-modeling-python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth's mass (kg) # Orbital radii (from 1e6 m to 1e7 m) R = np.linspace(1e6, 1e7, 100) # Calculate orbital period (T) using Kepler's Third Law T = np.sqrt((4 * np.pi**2 * R**3) / (G * M)) # Plot T^2 vs R^3 plt.figure(figsize=(10, 6)) plt.plot(R**3, T**2, 'b-', label='Simulation Data') plt.xlabel('Orbital Radius Cubed (R\u00b3) [m\u00b3]') plt.ylabel('Orbital Period Squared (T\u00b2) [s\u00b2]') plt.title('Verification of Kepler\\'s Third Law') plt.grid(True) plt.legend() plt.show()","title":"4. Computational Modeling: Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-results-and-observations","text":"","title":"5. Results and Observations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#51-simulation-results","text":"The plot of \\(T^2\\) vs \\(R^3\\) shows a straight line, confirming the proportionality predicted by Kepler's Third Law. This verifies that the square of the orbital period is directly proportional to the cube of the orbital radius.","title":"5.1 Simulation Results"},{"location":"1%20Physics/2%20Gravity/Problem_1/#52-key-takeaways","text":"Kepler's Third Law applies universally to any object in a circular orbit, whether it's a planet, satellite, or exoplanet. The relationship \\(T^2 \\propto R^3\\) allows us to calculate unknown masses or orbital parameters in astrophysical systems.","title":"5.2 Key Takeaways"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities: Imagine you're trying to throw a ball so hard that it leaves Earth and never comes back. Or picture a rocket zooming into space to orbit the planet or travel to Mars. To make these things happen, we need to understand escape velocity and cosmic velocities . These are special speeds that objects need to reach to overcome gravity and move through space. What Are Escape and Cosmic Velocities? Gravity is like an invisible force that pulls things toward the ground. If you want to escape gravity, you need to move really, really fast. The speeds required for different space tasks are called escape velocity and cosmic velocities . Let\u2019s break them down: First Cosmic Velocity (Orbital Velocity) : This is the speed needed to orbit a planet, like a satellite circling Earth. The object stays close to the planet, moving fast enough so gravity doesn\u2019t pull it back down, but not so fast that it escapes into space. Second Cosmic Velocity (Escape Velocity) : This is the speed needed to completely break free from a planet\u2019s gravity. If a rocket reaches this speed, it can leave Earth and travel into deep space without falling back. Third Cosmic Velocity : This is the speed needed to escape the gravitational pull of a star, like our Sun, and leave the star system. For example, a spacecraft leaving Earth to travel beyond our Solar System needs this speed. Think of it like this: - First : Stay in a circle around the planet (like a hula hoop). - Second : Fly away from the planet forever. - Third : Leave the whole star system and go to another one. The Math Behind These Velocities Don\u2019t worry if math sounds scary! We\u2019ll explain it step-by-step, like following a recipe. These velocities depend on two main things: - Mass of the planet or star (how heavy it is). - Radius (how big it is, measured from the center to the surface). We also use a special number called the gravitational constant ( \\(G\\) ) , which is like a rule that applies everywhere in the universe. Its value is: \\[ G = 6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\] First Cosmic Velocity (Orbital Velocity) To orbit a planet, an object needs to move fast enough so that the pull of gravity keeps it in a circular path, like swinging a ball on a string. The formula is: \\[ v_1 = \\sqrt{\\frac{G \\cdot M}{r}} \\] \\(M\\) : Mass of the planet (in kilograms). \\(r\\) : Radius of the planet (in meters). \\(G\\) : Gravitational constant. This speed ensures the object stays in orbit without falling back or flying away. Second Cosmic Velocity (Escape Velocity) To escape a planet\u2019s gravity entirely, an object needs enough energy to overcome the gravitational pull. The formula is: \\[ v_2 = \\sqrt{\\frac{2 \\cdot G \\cdot M}{r}} \\] Notice that this is just the first cosmic velocity multiplied by \\(\\sqrt{2}\\) : \\[ v_2 = v_1 \\cdot \\sqrt{2} \\] This makes sense because escaping requires more energy than just orbiting. Third Cosmic Velocity This one is trickier. It\u2019s the speed needed to escape a star\u2019s gravity (like the Sun) from the orbit of a planet (like Earth). The formula depends on the planet\u2019s orbit around the star and the star\u2019s mass. For a spacecraft leaving Earth to escape the Sun\u2019s gravity, the formula is complex, but a simplified version gives: \\[ v_3 = \\sqrt{\\frac{2 \\cdot G \\cdot M_{\\text{sun}}}{R_{\\text{orbit}}}} + v_{\\text{planet}} \\] \\(M_{\\text{sun}}\\) : Mass of the Sun. \\(R_{\\text{orbit}}\\) : Distance from the Sun to the planet (e.g., Earth\u2019s orbit radius). \\(v_{\\text{planet}}\\) : The planet\u2019s orbital speed around the Sun. This speed is much higher because the Sun is way bigger and heavier than Earth. Calculating Velocities for Earth, Mars, and Jupiter Let\u2019s calculate these velocities for three celestial bodies: Earth , Mars , and Jupiter . We\u2019ll use the following data: Celestial Body Mass ( \\(M\\) , kg) Radius ( \\(r\\) , m) Distance from Sun ( \\(R_{\\text{orbit}}\\) , m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) \\(1.496 \\times 10^{11}\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.899 \\times 10^{27}\\) \\(6.991 \\times 10^7\\) \\(7.785 \\times 10^{11}\\) Sun \\(1.989 \\times 10^{30}\\) - - Python script to calculate: - First cosmic velocity (orbital velocity). - Second cosmic velocity (escape velocity). - Third cosmic velocity (to escape the Sun, starting from each planet\u2019s orbit). Python Script import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Data for celestial bodies bodies = { 'Earth': { 'mass': 5.972e24, # kg 'radius': 6.371e6, # m 'orbit_radius': 1.496e11, # m (distance from Sun) 'orbital_velocity_sun': 29.78e3 # m/s (Earth's speed around Sun) }, 'Mars': { 'mass': 6.417e23, 'radius': 3.390e6, 'orbit_radius': 2.279e11, 'orbital_velocity_sun': 24.13e3 }, 'Jupiter': { 'mass': 1.899e27, 'radius': 6.991e7, 'orbit_radius': 7.785e11, 'orbital_velocity_sun': 13.07e3 } } sun_mass = 1.989e30 # Mass of the Sun (kg) # Calculate velocities v1_list = [] # First cosmic velocity (orbital) v2_list = [] # Second cosmic velocity (escape) v3_list = [] # Third cosmic velocity (escape Sun) names = [] for body, data in bodies.items(): # First cosmic velocity: v1 = sqrt(G * M / r) v1 = np.sqrt(G * data['mass'] / data['radius']) / 1000 # Convert to km/s # Second cosmic velocity: v2 = sqrt(2 * G * M / r) v2 = np.sqrt(2 * G * data['mass'] / data['radius']) / 1000 # Convert to km/s # Third cosmic velocity: Approximate as escape velocity from Sun at planet's orbit v_sun_escape = np.sqrt(2 * G * sun_mass / data['orbit_radius']) / 1000 # km/s v3 = v_sun_escape + (data['orbital_velocity_sun'] / 1000) # Add planet's orbital velocity v1_list.append(v1) v2_list.append(v2) v3_list.append(v3) names.append(body) # Plotting plt.figure(figsize=(10, 6)) bar_width = 0.25 index = np.arange(len(names)) plt.bar(index, v1_list, bar_width, label='First Cosmic Velocity (Orbital)', color='blue') plt.bar(index + bar_width, v2_list, bar_width, label='Second Cosmic Velocity (Escape)', color='green') plt.bar(index + 2 * bar_width, v3_list, bar_width, label='Third Cosmic Velocity (Sun Escape)', color='red') plt.xlabel('Celestial Body') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.xticks(index + bar_width, names) plt.legend() plt.grid(True, axis='y') plt.tight_layout() plt.savefig('cosmic_velocities.png') plt.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"Imagine you're trying to throw a ball so hard that it leaves Earth and never comes back. Or picture a rocket zooming into space to orbit the planet or travel to Mars. To make these things happen, we need to understand escape velocity and cosmic velocities . These are special speeds that objects need to reach to overcome gravity and move through space.","title":"Escape Velocities and Cosmic Velocities:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#what-are-escape-and-cosmic-velocities","text":"Gravity is like an invisible force that pulls things toward the ground. If you want to escape gravity, you need to move really, really fast. The speeds required for different space tasks are called escape velocity and cosmic velocities . Let\u2019s break them down: First Cosmic Velocity (Orbital Velocity) : This is the speed needed to orbit a planet, like a satellite circling Earth. The object stays close to the planet, moving fast enough so gravity doesn\u2019t pull it back down, but not so fast that it escapes into space. Second Cosmic Velocity (Escape Velocity) : This is the speed needed to completely break free from a planet\u2019s gravity. If a rocket reaches this speed, it can leave Earth and travel into deep space without falling back. Third Cosmic Velocity : This is the speed needed to escape the gravitational pull of a star, like our Sun, and leave the star system. For example, a spacecraft leaving Earth to travel beyond our Solar System needs this speed. Think of it like this: - First : Stay in a circle around the planet (like a hula hoop). - Second : Fly away from the planet forever. - Third : Leave the whole star system and go to another one.","title":"What Are Escape and Cosmic Velocities?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#the-math-behind-these-velocities","text":"Don\u2019t worry if math sounds scary! We\u2019ll explain it step-by-step, like following a recipe. These velocities depend on two main things: - Mass of the planet or star (how heavy it is). - Radius (how big it is, measured from the center to the surface). We also use a special number called the gravitational constant ( \\(G\\) ) , which is like a rule that applies everywhere in the universe. Its value is: \\[ G = 6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\]","title":"The Math Behind These Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"To orbit a planet, an object needs to move fast enough so that the pull of gravity keeps it in a circular path, like swinging a ball on a string. The formula is: \\[ v_1 = \\sqrt{\\frac{G \\cdot M}{r}} \\] \\(M\\) : Mass of the planet (in kilograms). \\(r\\) : Radius of the planet (in meters). \\(G\\) : Gravitational constant. This speed ensures the object stays in orbit without falling back or flying away.","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"To escape a planet\u2019s gravity entirely, an object needs enough energy to overcome the gravitational pull. The formula is: \\[ v_2 = \\sqrt{\\frac{2 \\cdot G \\cdot M}{r}} \\] Notice that this is just the first cosmic velocity multiplied by \\(\\sqrt{2}\\) : \\[ v_2 = v_1 \\cdot \\sqrt{2} \\] This makes sense because escaping requires more energy than just orbiting.","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"This one is trickier. It\u2019s the speed needed to escape a star\u2019s gravity (like the Sun) from the orbit of a planet (like Earth). The formula depends on the planet\u2019s orbit around the star and the star\u2019s mass. For a spacecraft leaving Earth to escape the Sun\u2019s gravity, the formula is complex, but a simplified version gives: \\[ v_3 = \\sqrt{\\frac{2 \\cdot G \\cdot M_{\\text{sun}}}{R_{\\text{orbit}}}} + v_{\\text{planet}} \\] \\(M_{\\text{sun}}\\) : Mass of the Sun. \\(R_{\\text{orbit}}\\) : Distance from the Sun to the planet (e.g., Earth\u2019s orbit radius). \\(v_{\\text{planet}}\\) : The planet\u2019s orbital speed around the Sun. This speed is much higher because the Sun is way bigger and heavier than Earth.","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculating-velocities-for-earth-mars-and-jupiter","text":"Let\u2019s calculate these velocities for three celestial bodies: Earth , Mars , and Jupiter . We\u2019ll use the following data: Celestial Body Mass ( \\(M\\) , kg) Radius ( \\(r\\) , m) Distance from Sun ( \\(R_{\\text{orbit}}\\) , m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) \\(1.496 \\times 10^{11}\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.899 \\times 10^{27}\\) \\(6.991 \\times 10^7\\) \\(7.785 \\times 10^{11}\\) Sun \\(1.989 \\times 10^{30}\\) - - Python script to calculate: - First cosmic velocity (orbital velocity). - Second cosmic velocity (escape velocity). - Third cosmic velocity (to escape the Sun, starting from each planet\u2019s orbit).","title":"Calculating Velocities for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-script","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Data for celestial bodies bodies = { 'Earth': { 'mass': 5.972e24, # kg 'radius': 6.371e6, # m 'orbit_radius': 1.496e11, # m (distance from Sun) 'orbital_velocity_sun': 29.78e3 # m/s (Earth's speed around Sun) }, 'Mars': { 'mass': 6.417e23, 'radius': 3.390e6, 'orbit_radius': 2.279e11, 'orbital_velocity_sun': 24.13e3 }, 'Jupiter': { 'mass': 1.899e27, 'radius': 6.991e7, 'orbit_radius': 7.785e11, 'orbital_velocity_sun': 13.07e3 } } sun_mass = 1.989e30 # Mass of the Sun (kg) # Calculate velocities v1_list = [] # First cosmic velocity (orbital) v2_list = [] # Second cosmic velocity (escape) v3_list = [] # Third cosmic velocity (escape Sun) names = [] for body, data in bodies.items(): # First cosmic velocity: v1 = sqrt(G * M / r) v1 = np.sqrt(G * data['mass'] / data['radius']) / 1000 # Convert to km/s # Second cosmic velocity: v2 = sqrt(2 * G * M / r) v2 = np.sqrt(2 * G * data['mass'] / data['radius']) / 1000 # Convert to km/s # Third cosmic velocity: Approximate as escape velocity from Sun at planet's orbit v_sun_escape = np.sqrt(2 * G * sun_mass / data['orbit_radius']) / 1000 # km/s v3 = v_sun_escape + (data['orbital_velocity_sun'] / 1000) # Add planet's orbital velocity v1_list.append(v1) v2_list.append(v2) v3_list.append(v3) names.append(body) # Plotting plt.figure(figsize=(10, 6)) bar_width = 0.25 index = np.arange(len(names)) plt.bar(index, v1_list, bar_width, label='First Cosmic Velocity (Orbital)', color='blue') plt.bar(index + bar_width, v2_list, bar_width, label='Second Cosmic Velocity (Escape)', color='green') plt.bar(index + 2 * bar_width, v3_list, bar_width, label='Third Cosmic Velocity (Sun Escape)', color='red') plt.xlabel('Celestial Body') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.xticks(index + bar_width, names) plt.legend() plt.grid(True, axis='y') plt.tight_layout() plt.savefig('cosmic_velocities.png') plt.show()","title":"Python Script"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Payload Trajectories Near Earth This report analyzes the trajectories of a payload released from a rocket near Earth. It explores elliptical, parabolic, and hyperbolic paths based on initial conditions. Python simulations visualize these trajectories, relating them to applications like satellite deployment and interplanetary missions. Theoretical Background: Gravitational Force: The motion is governed by Newton's Law of Universal Gravitation: \\(F = \\frac{G M m}{r^2}\\) , where: \\(G\\) is the gravitational constant. \\(M\\) is Earth's mass. \\(m\\) is the payload's mass. \\(r\\) is the distance between Earth and the payload. Equations of Motion: To model the motion, we use a 2D Cartesian coordinate system, resulting in: \\(\\ddot{x} = -\\frac{G M x}{r^3}, \\quad \\ddot{y} = -\\frac{G M y}{r^3}\\) Trajectory Types: Determined by the specific mechanical energy: \\(\\epsilon = \\frac{v^2}{2} - \\frac{G M}{r}\\) Elliptical ( \\(\\epsilon < 0\\) ): Closed orbit. Parabolic ( \\(\\epsilon = 0\\) ): Escape threshold. Hyperbolic ( \\(\\epsilon > 0\\) ): Escape trajectory. Escape Velocity: The minimum speed to escape Earth's gravity: \\(v_{\\text{esc}} = \\sqrt{\\frac{2 G M}{r}}\\) (approximately 11.2 km/s at 200 km altitude). Python Implementation: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Physical constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth\u2019s mass (kg) R_E = 6.371e6 # Earth\u2019s radius (m) mu = G * M # Gravitational parameter (m^3 s^-2) # Equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] # Specific mechanical energy def specific_energy(x, y, vx, vy): r = np.sqrt(x**2 + y**2) v = np.sqrt(vx**2 + vy**2) return 0.5 * v**2 - mu / r # Simulate trajectories def simulate_trajectories(): # Initial conditions: 200 km altitude altitude = 200e3 r0 = R_E + altitude x0, y0 = 0, r0 # Time span: 1 day (86,400 seconds) t_span = (0, 86400) t_eval = np.linspace(0, 86400, 1000) # Initial velocities for different trajectories velocities = [ (0, 7.8e3, \"Elliptical\"), # Sub-escape velocity (0, 11.2e3, \"Parabolic\"), # Escape velocity (0, 15.0e3, \"Hyperbolic\") # Above escape velocity ] plt.figure(figsize=(10, 8)) # Plot Earth\u2019s surface theta = np.linspace(0, 2 * np.pi, 100) x_earth = R_E * np.cos(theta) y_earth = R_E * np.sin(theta) plt.plot(x_earth, y_earth, 'b-', label=\"Earth\") # Simulate and plot each trajectory for vx0, vy0, label in velocities: state0 = [x0, y0, vx0, vy0] sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, method='RK45') plt.plot(sol.y[0], sol.y[1], label=f\"{label} (v = {np.sqrt(vx0**2 + vy0**2)/1e3:.1f} km/s)\") # Compute and display energy energy = specific_energy(x0, y0, vx0, vy0) print(f\"{label} trajectory: Specific energy = {energy:.2e} J/kg\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.title(\"Trajectories of a Payload Near Earth\") plt.legend() plt.grid(True) plt.axis(\"equal\") plt.savefig(\"trajectories.png\") plt.show() simulate_trajectories()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#payload-trajectories-near-earth","text":"This report analyzes the trajectories of a payload released from a rocket near Earth. It explores elliptical, parabolic, and hyperbolic paths based on initial conditions. Python simulations visualize these trajectories, relating them to applications like satellite deployment and interplanetary missions. Theoretical Background: Gravitational Force: The motion is governed by Newton's Law of Universal Gravitation: \\(F = \\frac{G M m}{r^2}\\) , where: \\(G\\) is the gravitational constant. \\(M\\) is Earth's mass. \\(m\\) is the payload's mass. \\(r\\) is the distance between Earth and the payload. Equations of Motion: To model the motion, we use a 2D Cartesian coordinate system, resulting in: \\(\\ddot{x} = -\\frac{G M x}{r^3}, \\quad \\ddot{y} = -\\frac{G M y}{r^3}\\) Trajectory Types: Determined by the specific mechanical energy: \\(\\epsilon = \\frac{v^2}{2} - \\frac{G M}{r}\\) Elliptical ( \\(\\epsilon < 0\\) ): Closed orbit. Parabolic ( \\(\\epsilon = 0\\) ): Escape threshold. Hyperbolic ( \\(\\epsilon > 0\\) ): Escape trajectory. Escape Velocity: The minimum speed to escape Earth's gravity: \\(v_{\\text{esc}} = \\sqrt{\\frac{2 G M}{r}}\\) (approximately 11.2 km/s at 200 km altitude). Python Implementation: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Physical constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth\u2019s mass (kg) R_E = 6.371e6 # Earth\u2019s radius (m) mu = G * M # Gravitational parameter (m^3 s^-2) # Equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] # Specific mechanical energy def specific_energy(x, y, vx, vy): r = np.sqrt(x**2 + y**2) v = np.sqrt(vx**2 + vy**2) return 0.5 * v**2 - mu / r # Simulate trajectories def simulate_trajectories(): # Initial conditions: 200 km altitude altitude = 200e3 r0 = R_E + altitude x0, y0 = 0, r0 # Time span: 1 day (86,400 seconds) t_span = (0, 86400) t_eval = np.linspace(0, 86400, 1000) # Initial velocities for different trajectories velocities = [ (0, 7.8e3, \"Elliptical\"), # Sub-escape velocity (0, 11.2e3, \"Parabolic\"), # Escape velocity (0, 15.0e3, \"Hyperbolic\") # Above escape velocity ] plt.figure(figsize=(10, 8)) # Plot Earth\u2019s surface theta = np.linspace(0, 2 * np.pi, 100) x_earth = R_E * np.cos(theta) y_earth = R_E * np.sin(theta) plt.plot(x_earth, y_earth, 'b-', label=\"Earth\") # Simulate and plot each trajectory for vx0, vy0, label in velocities: state0 = [x0, y0, vx0, vy0] sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, method='RK45') plt.plot(sol.y[0], sol.y[1], label=f\"{label} (v = {np.sqrt(vx0**2 + vy0**2)/1e3:.1f} km/s)\") # Compute and display energy energy = specific_energy(x0, y0, vx0, vy0) print(f\"{label} trajectory: Specific energy = {energy:.2e} J/kg\") plt.xlabel(\"X (m)\") plt.ylabel(\"Y (m)\") plt.title(\"Trajectories of a Payload Near Earth\") plt.legend() plt.grid(True) plt.axis(\"equal\") plt.savefig(\"trajectories.png\") plt.show() simulate_trajectories()","title":"Payload Trajectories Near Earth"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Introduction Wave motion is a fundamental concept in physics that describes how energy is transferred through a medium without the transport of matter. Waves are all around us whether it\u2019s the sound we hear, the light we see, or the ripples on a pond. This problem focuses on understanding the basic principles of wave motion, including the mathematical description of waves, their properties, and their behavior in different scenarios. What is a Wave? A wave is a disturbance that travels through a medium, transferring energy from one point to another. Waves can be classified into two main types: Mechanical Waves : Require a medium to propagate (e.g., sound waves, water waves). Electromagnetic Waves : Do not require a medium and can travel through a vacuum (e.g., light, radio waves). Key Properties of Waves To understand wave motion, we need to define some key properties: Wavelength ( \\(\\lambda\\) ) : The distance between two consecutive points in phase on a wave (e.g., crest to crest or trough to trough). Measured in meters (m). Frequency ( \\(f\\) ) : The number of wave cycles that pass a given point per second. Measured in hertz (Hz). Period ( \\(T\\) ) : The time it takes for one complete wave cycle to pass a point. Related to frequency by: $$ T = \\frac{1}{f} $$ Wave Speed ( \\(v\\) $) : The speed at which the wave propagates through the medium. Related to wavelength and frequency by: $$ v = f \\lambda $$ Amplitude ( \\(A\\) ) : The maximum displacement of the wave from its equilibrium position. Determines the wave\u2019s energy. Mathematical Description of a Wave The general equation for a traveling wave is: \\[ y(x, t) = A \\sin(kx - \\omega t + \\phi) \\] Where: - \\(y(x, t)\\) : Displacement of the wave at position \\(x\\) and time \\(t\\) . - \\(A\\) : Amplitude of the wave. - \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number (spatial frequency). - \\(\\omega = 2\\pi f\\) : Angular frequency (temporal frequency). - \\(\\phi\\) : Phase constant, which determines the wave\u2019s initial position. Practical Applications of Wave Motion Communication : Radio and television signals use electromagnetic waves to transmit information. Seismology : Understanding wave motion helps scientists study earthquakes and the Earth\u2019s interior. Medical Imaging : Ultrasound waves are used to create images of internal body structures. Music : Sound waves are the basis of musical instruments and acoustics. Wave Simulation Using Python import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Wave parameters A = 0.05 # Amplitude (m) k = 4 * np.pi # Wave number (rad/m) omega = 20 * np.pi # Angular frequency (rad/s) lambda_ = 2 * np.pi / k # Wavelength (m) f = omega / (2 * np.pi) # Frequency (Hz) v = f * lambda_ # Wave speed (m/s) # Spatial and temporal domains x = np.linspace(0, 2, 500) # Position (m) t = np.linspace(0, 1, 100) # Time (s) # Wave function def wave(x, t): return A * np.sin(k * x - omega * t) # Create a figure for the animation fig, ax = plt.subplots(figsize=(8, 4)) ax.set_xlim(0, 2) ax.set_ylim(-A * 1.5, A * 1.5) ax.set_xlabel(\"Position (m)\") ax.set_ylabel(\"Displacement (m)\") ax.set_title(\"Wave Propagation\") line, = ax.plot([], [], lw=2) # Animation function def update(frame): y = wave(x, t[frame]) line.set_data(x, y) return line, # Create the animation ani = FuncAnimation(fig, update, frames=len(t), interval=50, blit=True) # Show the animation plt.show()","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#introduction","text":"Wave motion is a fundamental concept in physics that describes how energy is transferred through a medium without the transport of matter. Waves are all around us whether it\u2019s the sound we hear, the light we see, or the ripples on a pond. This problem focuses on understanding the basic principles of wave motion, including the mathematical description of waves, their properties, and their behavior in different scenarios.","title":"Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#what-is-a-wave","text":"A wave is a disturbance that travels through a medium, transferring energy from one point to another. Waves can be classified into two main types: Mechanical Waves : Require a medium to propagate (e.g., sound waves, water waves). Electromagnetic Waves : Do not require a medium and can travel through a vacuum (e.g., light, radio waves).","title":"What is a Wave?"},{"location":"1%20Physics/3%20Waves/Problem_1/#key-properties-of-waves","text":"To understand wave motion, we need to define some key properties: Wavelength ( \\(\\lambda\\) ) : The distance between two consecutive points in phase on a wave (e.g., crest to crest or trough to trough). Measured in meters (m). Frequency ( \\(f\\) ) : The number of wave cycles that pass a given point per second. Measured in hertz (Hz). Period ( \\(T\\) ) : The time it takes for one complete wave cycle to pass a point. Related to frequency by: $$ T = \\frac{1}{f} $$ Wave Speed ( \\(v\\) $) : The speed at which the wave propagates through the medium. Related to wavelength and frequency by: $$ v = f \\lambda $$ Amplitude ( \\(A\\) ) : The maximum displacement of the wave from its equilibrium position. Determines the wave\u2019s energy.","title":"Key Properties of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-description-of-a-wave","text":"The general equation for a traveling wave is: \\[ y(x, t) = A \\sin(kx - \\omega t + \\phi) \\] Where: - \\(y(x, t)\\) : Displacement of the wave at position \\(x\\) and time \\(t\\) . - \\(A\\) : Amplitude of the wave. - \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number (spatial frequency). - \\(\\omega = 2\\pi f\\) : Angular frequency (temporal frequency). - \\(\\phi\\) : Phase constant, which determines the wave\u2019s initial position.","title":"Mathematical Description of a Wave"},{"location":"1%20Physics/3%20Waves/Problem_1/#practical-applications-of-wave-motion","text":"Communication : Radio and television signals use electromagnetic waves to transmit information. Seismology : Understanding wave motion helps scientists study earthquakes and the Earth\u2019s interior. Medical Imaging : Ultrasound waves are used to create images of internal body structures. Music : Sound waves are the basis of musical instruments and acoustics.","title":"Practical Applications of Wave Motion"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-simulation-using-python","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Wave parameters A = 0.05 # Amplitude (m) k = 4 * np.pi # Wave number (rad/m) omega = 20 * np.pi # Angular frequency (rad/s) lambda_ = 2 * np.pi / k # Wavelength (m) f = omega / (2 * np.pi) # Frequency (Hz) v = f * lambda_ # Wave speed (m/s) # Spatial and temporal domains x = np.linspace(0, 2, 500) # Position (m) t = np.linspace(0, 1, 100) # Time (s) # Wave function def wave(x, t): return A * np.sin(k * x - omega * t) # Create a figure for the animation fig, ax = plt.subplots(figsize=(8, 4)) ax.set_xlim(0, 2) ax.set_ylim(-A * 1.5, A * 1.5) ax.set_xlabel(\"Position (m)\") ax.set_ylabel(\"Displacement (m)\") ax.set_title(\"Wave Propagation\") line, = ax.plot([], [], lw=2) # Animation function def update(frame): y = wave(x, t[frame]) line.set_data(x, y) return line, # Create the animation ani = FuncAnimation(fig, update, frames=len(t), interval=50, blit=True) # Show the animation plt.show()","title":"Wave Simulation Using Python"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Introduction The Lorentz force is a cornerstone of electromagnetism, describing the force experienced by a charged particle moving in electric and magnetic fields. It is mathematically expressed as: \\[ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\(\\vec{F}\\) : Lorentz force (N), representing the total electromagnetic force on the charged particle (measured in Newtons). - \\(q\\) : Charge of the particle (C), indicating the magnitude and sign of the electric charge (measured in Coulombs). - \\(\\vec{E}\\) : Electric field (V/m), representing the force per unit charge due to electric potential differences (measured in Volts per meter). - \\(\\vec{B}\\) : Magnetic field (T), representing the magnetic influence on moving electric charges (measured in Teslas). - \\(\\vec{v}\\) : Velocity of the particle (m/s), indicating the speed and direction of the particle's motion (measured in meters per second). This force governs the motion of charged particles in systems such as particle accelerators, mass spectrometers, and plasma confinement devices. By simulating the trajectories of particles under the influence of the Lorentz force, we can gain insights into its applications and visualize the complex dynamics it produces. The simulation will allow us to explore how different field configurations and initial conditions affect the particle's path, providing a deeper understanding of electromagnetic phenomena. Applications of the Lorentz Force 1. Particle Accelerators In devices like cyclotrons and synchrotrons, magnetic fields bend the paths of charged particles into circular trajectories, while electric fields accelerate them to high speeds. The Lorentz force is precisely controlled to maintain the particles within the accelerator's beam path, enabling high-energy collisions for fundamental physics research. 2. Mass Spectrometers Charged particles are deflected by magnetic fields based on their mass-to-charge ratio ( \\(m/q\\) ), enabling the identification of chemical compounds. The Lorentz force acts as a \"selector,\" allowing only particles with specific \\(m/q\\) values to reach the detector, thus enabling accurate mass analysis. 3. Plasma Confinement In fusion reactors, magnetic fields confine plasma (a hot, ionized gas) to prevent it from coming into contact with reactor walls. The Lorentz force is crucial for maintaining plasma stability and achieving the high temperatures and densities required for nuclear fusion. 4. Astrophysics The Lorentz force explains the motion of charged particles in cosmic magnetic fields, such as those in solar winds, around pulsars, or in the Earth's magnetosphere. These interactions lead to phenomena like auroras and the trapping of charged particles in the Van Allen radiation belts. Simulating Particle Motion Equations of Motion The motion of a charged particle under the Lorentz force is governed by Newton's second law: \\[ m \\frac{d\\vec{v}}{dt} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This equation can be broken into components for numerical simulation: - \\( \\(\\frac{dv_x}{dt} = \\frac{q}{m} (E_x + v_y B_z - v_z B_y)\\) \\) - \\( \\(\\frac{dv_y}{dt} = \\frac{q}{m} (E_y + v_z B_x - v_x B_z)\\) \\) - \\( \\(\\frac{dv_z}{dt} = \\frac{q}{m} (E_z + v_x B_y - v_y B_x)\\) \\) The position of the particle is updated using: - \\( \\(\\frac{dx}{dt} = v_x, \\quad \\frac{dy}{dt} = v_y, \\quad \\frac{dz}{dt} = v_z\\) \\) These equations describe how the velocity and position of the particle evolve over time under the influence of electric and magnetic fields. To simulate this motion, we will use numerical methods to approximate the solutions to these differential equations. Simulation: Uniform Magnetic Field import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle (C) m = 9.11e-31 # Mass of the particle (kg) B = np.array([0, 0, 1]) # Magnetic field (T) E = np.array([0, 0, 0]) # Electric field (V/m) dt = 1e-11 # Time step (s) steps = 10000 # Number of simulation steps # Initial conditions r = np.zeros((steps, 3)) # Position (m) v = np.zeros((steps, 3)) # Velocity (m/s) v[0] = [1e6, 0, 0] # Initial velocity (m/s) # Simulation loop for i in range(steps - 1): # Calculate the Lorentz force F = q * (E + np.cross(v[i], B)) # Lorentz force a = F / m # Acceleration v[i + 1] = v[i] + a * dt # Update velocity r[i + 1] = r[i] + v[i] * dt # Update position # Visualization fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label=\"Particle Trajectory\") ax.set_xlabel(\"X (m)\") ax.set_ylabel(\"Y (m)\") ax.set_zlabel(\"Z (m)\") ax.set_title(\"Particle Motion in a Uniform Magnetic Field\") ax.legend() plt.show()","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction","text":"The Lorentz force is a cornerstone of electromagnetism, describing the force experienced by a charged particle moving in electric and magnetic fields. It is mathematically expressed as: \\[ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\(\\vec{F}\\) : Lorentz force (N), representing the total electromagnetic force on the charged particle (measured in Newtons). - \\(q\\) : Charge of the particle (C), indicating the magnitude and sign of the electric charge (measured in Coulombs). - \\(\\vec{E}\\) : Electric field (V/m), representing the force per unit charge due to electric potential differences (measured in Volts per meter). - \\(\\vec{B}\\) : Magnetic field (T), representing the magnetic influence on moving electric charges (measured in Teslas). - \\(\\vec{v}\\) : Velocity of the particle (m/s), indicating the speed and direction of the particle's motion (measured in meters per second). This force governs the motion of charged particles in systems such as particle accelerators, mass spectrometers, and plasma confinement devices. By simulating the trajectories of particles under the influence of the Lorentz force, we can gain insights into its applications and visualize the complex dynamics it produces. The simulation will allow us to explore how different field configurations and initial conditions affect the particle's path, providing a deeper understanding of electromagnetic phenomena.","title":"Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#applications-of-the-lorentz-force","text":"","title":"Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-particle-accelerators","text":"In devices like cyclotrons and synchrotrons, magnetic fields bend the paths of charged particles into circular trajectories, while electric fields accelerate them to high speeds. The Lorentz force is precisely controlled to maintain the particles within the accelerator's beam path, enabling high-energy collisions for fundamental physics research.","title":"1. Particle Accelerators"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-mass-spectrometers","text":"Charged particles are deflected by magnetic fields based on their mass-to-charge ratio ( \\(m/q\\) ), enabling the identification of chemical compounds. The Lorentz force acts as a \"selector,\" allowing only particles with specific \\(m/q\\) values to reach the detector, thus enabling accurate mass analysis.","title":"2. Mass Spectrometers"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-plasma-confinement","text":"In fusion reactors, magnetic fields confine plasma (a hot, ionized gas) to prevent it from coming into contact with reactor walls. The Lorentz force is crucial for maintaining plasma stability and achieving the high temperatures and densities required for nuclear fusion.","title":"3. Plasma Confinement"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-astrophysics","text":"The Lorentz force explains the motion of charged particles in cosmic magnetic fields, such as those in solar winds, around pulsars, or in the Earth's magnetosphere. These interactions lead to phenomena like auroras and the trapping of charged particles in the Van Allen radiation belts.","title":"4. Astrophysics"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-particle-motion","text":"","title":"Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#equations-of-motion","text":"The motion of a charged particle under the Lorentz force is governed by Newton's second law: \\[ m \\frac{d\\vec{v}}{dt} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This equation can be broken into components for numerical simulation: - \\( \\(\\frac{dv_x}{dt} = \\frac{q}{m} (E_x + v_y B_z - v_z B_y)\\) \\) - \\( \\(\\frac{dv_y}{dt} = \\frac{q}{m} (E_y + v_z B_x - v_x B_z)\\) \\) - \\( \\(\\frac{dv_z}{dt} = \\frac{q}{m} (E_z + v_x B_y - v_y B_x)\\) \\) The position of the particle is updated using: - \\( \\(\\frac{dx}{dt} = v_x, \\quad \\frac{dy}{dt} = v_y, \\quad \\frac{dz}{dt} = v_z\\) \\) These equations describe how the velocity and position of the particle evolve over time under the influence of electric and magnetic fields. To simulate this motion, we will use numerical methods to approximate the solutions to these differential equations.","title":"Equations of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-uniform-magnetic-field","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle (C) m = 9.11e-31 # Mass of the particle (kg) B = np.array([0, 0, 1]) # Magnetic field (T) E = np.array([0, 0, 0]) # Electric field (V/m) dt = 1e-11 # Time step (s) steps = 10000 # Number of simulation steps # Initial conditions r = np.zeros((steps, 3)) # Position (m) v = np.zeros((steps, 3)) # Velocity (m/s) v[0] = [1e6, 0, 0] # Initial velocity (m/s) # Simulation loop for i in range(steps - 1): # Calculate the Lorentz force F = q * (E + np.cross(v[i], B)) # Lorentz force a = F / m # Acceleration v[i + 1] = v[i] + a * dt # Update velocity r[i + 1] = r[i] + v[i] * dt # Update position # Visualization fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label=\"Particle Trajectory\") ax.set_xlabel(\"X (m)\") ax.set_ylabel(\"Y (m)\") ax.set_zlabel(\"Z (m)\") ax.set_title(\"Particle Motion in a Uniform Magnetic Field\") ax.legend() plt.show()","title":"Simulation: Uniform Magnetic Field"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Calculation Using Graph Theory Introduction Calculating the equivalent resistance of a circuit is a fundamental problem in electrical engineering. Traditional methods, which involve iteratively applying series and parallel resistor rules, can become complex and cumbersome for intricate circuits. Graph theory offers a powerful and systematic alternative by representing a circuit as a graph, where nodes are junctions and edges are resistors. This approach not only simplifies calculations but also provides a deeper understanding of circuit analysis. Theory Traditional Methods vs. Graph Theory Traditional Methods : Iteratively applying series and parallel resistor rules. Graph Theory : Representing a circuit as a graph simplifies complex networks. Benefits of Using Graph Theory Systematic Approach : Provides a structured way to analyze circuits. Simplification : Simplifies complex networks into manageable graphs. Automation : Enables automated circuit analysis, useful in simulation software. Versatility : Highlights the interplay between electrical and mathematical concepts. Task: Implementing Equivalent Resistance Calculation Using Graph Theory Algorithm Description The algorithm for calculating equivalent resistance using graph theory involves the following steps: Graph Representation : Represent the circuit as a graph where: Nodes: Junctions in the circuit. Edges: Resistors connecting the junctions. Edge Weights: Resistance values of the resistors. Iterative Simplification : Iteratively reduce the graph by identifying and simplifying series and parallel connections. Series Reduction : Identify series connections (linear chains of resistors). Replace each series connection with a single equivalent resistor by summing their resistance values. Parallel Reduction : Identify parallel connections (resistors connected between the same two nodes). Replace each parallel connection with a single equivalent resistor using the formula: $$ R_{\\text{eq}} = \\left( \\sum_{i=1}^{n} \\frac{1}{R_i} \\right)^{-1} $$ Termination : Repeat steps 3 and 4 until the graph is reduced to a single equivalent resistance between the input and output nodes. Python Implementation import networkx as nx import matplotlib.pyplot as plt import numpy as np def calculate_equivalent_resistance(graph, input_node, output_node): \"\"\" Calculate the equivalent resistance of a circuit represented as a graph. Parameters: - graph (nx.Graph): A networkx graph representing the circuit. Nodes are junctions, and edges are resistors with 'resistance' attribute. - input_node (str): The starting node for resistance calculation. - output_node (str): The ending node for resistance calculation. Returns: - float: The equivalent resistance between the input and output nodes. \"\"\" graph = graph.copy() # Operate on a copy to avoid modifying the original graph while len(graph.nodes) > 2: # Series Reduction for node in list(graph.nodes): # Iterate over a copy of the nodes if graph.degree(node) == 2: edges = list(graph.edges(node, data=True)) if len(edges) == 2: node1, node2, data1 = edges[0][0], edges[0][1], edges[0][2] node3, node4, data2 = edges[1][0], edges[1][1], edges[1][2] r1 = data1['resistance'] r2 = data2['resistance'] R_eq = r1 + r2 # Remove the series connection graph.remove_node(node) # Add the equivalent resistor new_node1 = node1 if node1 != node else node3 new_node2 = node2 if node2 != node else node4 graph.add_edge(new_node1, new_node2, resistance=R_eq) break # Break to restart the loop after modification # Parallel Reduction for node1 in list(graph.nodes): for node2 in list(graph.nodes): if node1 != node2 and graph.has_edge(node1, node2): edges_between = [(u, v, data) for u, v, data in graph.edges(data=True) if ((u == node1 and v == node2) or (u == node2 and v == node1))] if len(edges_between) > 1: R_eq = (sum(1 / data['resistance'] for u, v, data in edges_between))**(-1) # Remove parallel resistors edges_to_remove = [(u, v) for u, v, data in edges_between] for u, v in edges_to_remove: graph.remove_edge(u, v) # Add the equivalent resistor graph.add_edge(node1, node2, resistance=R_eq) break # Break to restart the loop after modification # Return the final equivalent resistance for u, v, data in graph.edges(data=True): return data['resistance'] return 0 # If no resistance is found def visualize_circuit(graph, title=\"Circuit Diagram\", pos=None): \"\"\" Visualizes the circuit graph using matplotlib. \"\"\" if pos is None: pos = nx.spring_layout(graph) # You can use other layout algorithms plt.figure(figsize=(10, 8)) # Adjust figure size for better visualization nx.draw(graph, pos, with_labels=True, node_color='skyblue', node_size=800, font_size=12, font_weight='bold', edgecolors='gray', linewidths=0.5) # Added edgecolors for better node visibility edge_labels = nx.get_edge_attributes(graph, 'resistance') nx.draw_networkx_edge_labels(graph, pos, edge_labels=edge_labels, font_size=10, bbox=dict(alpha=0.7, edgecolor=\"none\")) # Added bbox for label readability plt.title(title, fontsize=16) # Increased title font size plt.box(False) # Remove the surrounding box plt.show() return pos # Return the layout for consistent visualization def simulate_circuit(graph, input_node, output_node, voltage_source): # Create the admittance matrix and source vector num_nodes = len(graph.nodes) node_index = {node: i for i, node in enumerate(graph.nodes)} Y = np.zeros((num_nodes, num_nodes)) I = np.zeros(num_nodes) # Fill the admittance matrix for u, v, data in graph.edges(data=True): r = data['resistance'] g = 1 / r # Conductance i = node_index[u] j = node_index[v] Y[i, i] += g Y[j, j] += g Y[i, j] -= g Y[j, i] -= g # Add the voltage source input_index = node_index[input_node] output_index = node_index[output_node] Y[input_index, :] = 0 Y[output_index, :] = 0 Y[input_index, input_index] = 1 Y[output_index, output_index] = 1 I[input_index] = voltage_source I[output_index] = 0 # Solve for node voltages try: V = np.linalg.solve(Y, I) except np.linalg.LinAlgError: print(\"Singular matrix! Check your circuit configuration.\") return None node_voltages = {node: V[i] for node, i in node_index.items()} # Calculate edge currents edge_currents = {} for u, v, data in graph.edges(data=True): r = data['resistance'] V_u = node_voltages[u] V_v = node_voltages[v] I_uv = (V_u - V_v) / r edge_currents[(u, v)] = I_uv return node_voltages, edge_currents def display_simulation_results(graph, node_voltages, edge_currents, pos): if node_voltages is None: return plt.figure(figsize=(12, 10)) nx.draw(graph, pos, with_labels=True, node_color='skyblue', node_size=800, font_size=12, font_weight='bold', edgecolors='gray', linewidths=0.5) # Display resistance values edge_labels_resistance = nx.get_edge_attributes(graph, 'resistance') nx.draw_networkx_edge_labels(graph, pos, edge_labels=edge_labels_resistance, font_size=8, bbox=dict(alpha=0.7, edgecolor=\"none\")) # Display voltage values node_labels_voltage = {node: f\"{voltage:.2f}V\" for node, voltage in node_voltages.items()} nx.draw_networkx_labels(graph, pos, labels=node_labels_voltage, font_size=8, font_color='green', bbox=dict(alpha=0.7, edgecolor=\"none\")) # Display current values edge_labels_current = {edge: f\"{current:.2f}A\" for edge, current in edge_currents.items()} nx.draw_networkx_edge_labels(graph, pos, edge_labels=edge_labels_current, font_size=8, font_color='red', bbox=dict(alpha=0.7, edgecolor=\"none\"), label_pos=0.7) # Adjust label_pos for better placement plt.title(\"Circuit Simulation Results\", fontsize=16) plt.box(False) plt.show() # Example 1: Simple Series and Parallel Combination graph1 = nx.Graph() graph1.add_edge('A', 'B', resistance=10) graph1.add_edge('B', 'C', resistance=20) graph1.add_edge('A', 'C', resistance=30) pos1 = visualize_circuit(graph1, title=\"Example 1: Simple Series and Parallel\") R_eq1 = calculate_equivalent_resistance(graph1, 'A', 'C') print(f\"Equivalent Resistance for Example 1: {R_eq1:.2f} ohms\") node_voltages1, edge_currents1 = simulate_circuit(graph1, 'A', 'C', 12) if node_voltages1: display_simulation_results(graph1, node_voltages1, edge_currents1, pos1) # Example 2: Nested Configuration graph2 = nx.Graph() graph2.add_edge('A', 'B', resistance=10) graph2.add_edge('B', 'C', resistance=20) graph2.add_edge('A', 'D', resistance=30) graph2.add_edge('D', 'C', resistance=40) pos2 = visualize_circuit(graph2, title=\"Example 2: Nested Configuration\") R_eq2 = calculate_equivalent_resistance(graph2, 'A', 'C') print(f\"Equivalent Resistance for Example 2: {R_eq2:.2f} ohms\") node_voltages2, edge_currents2 = simulate_circuit(graph2, 'A', 'C', 12) if node_voltages2: display_simulation_results(graph2, node_voltages2, edge_currents2, pos2) # Example 3: Complex Graph with Multiple Cycles graph3 = nx.Graph() graph3.add_edge('A', 'B', resistance=10) graph3.add_edge('B', 'C', resistance=20) graph3.add_edge('C', 'D', resistance=30) graph3.add_edge('D', 'A', resistance=40) graph3.add_edge('A', 'C', resistance=50) pos3 = visualize_circuit(graph3, title=\"Example 3: Complex Graph with Multiple Cycles\") R_eq3 = calculate_equivalent_resistance(graph3, 'A', 'D') print(f\"Equivalent Resistance for Example 3: {R_eq3:.2f} ohms\") node_voltages3, edge_currents3 = simulate_circuit(graph3, 'A', 'D', 12) if node_voltages3: display_simulation_results(graph3, node_voltages3, edge_currents3, pos3)","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-calculation-using-graph-theory","text":"","title":"Equivalent Resistance Calculation Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#introduction","text":"Calculating the equivalent resistance of a circuit is a fundamental problem in electrical engineering. Traditional methods, which involve iteratively applying series and parallel resistor rules, can become complex and cumbersome for intricate circuits. Graph theory offers a powerful and systematic alternative by representing a circuit as a graph, where nodes are junctions and edges are resistors. This approach not only simplifies calculations but also provides a deeper understanding of circuit analysis.","title":"Introduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#theory","text":"","title":"Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#traditional-methods-vs-graph-theory","text":"Traditional Methods : Iteratively applying series and parallel resistor rules. Graph Theory : Representing a circuit as a graph simplifies complex networks.","title":"Traditional Methods vs. Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#benefits-of-using-graph-theory","text":"Systematic Approach : Provides a structured way to analyze circuits. Simplification : Simplifies complex networks into manageable graphs. Automation : Enables automated circuit analysis, useful in simulation software. Versatility : Highlights the interplay between electrical and mathematical concepts.","title":"Benefits of Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-implementing-equivalent-resistance-calculation-using-graph-theory","text":"","title":"Task: Implementing Equivalent Resistance Calculation Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-description","text":"The algorithm for calculating equivalent resistance using graph theory involves the following steps: Graph Representation : Represent the circuit as a graph where: Nodes: Junctions in the circuit. Edges: Resistors connecting the junctions. Edge Weights: Resistance values of the resistors. Iterative Simplification : Iteratively reduce the graph by identifying and simplifying series and parallel connections. Series Reduction : Identify series connections (linear chains of resistors). Replace each series connection with a single equivalent resistor by summing their resistance values. Parallel Reduction : Identify parallel connections (resistors connected between the same two nodes). Replace each parallel connection with a single equivalent resistor using the formula: $$ R_{\\text{eq}} = \\left( \\sum_{i=1}^{n} \\frac{1}{R_i} \\right)^{-1} $$ Termination : Repeat steps 3 and 4 until the graph is reduced to a single equivalent resistance between the input and output nodes.","title":"Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation","text":"import networkx as nx import matplotlib.pyplot as plt import numpy as np def calculate_equivalent_resistance(graph, input_node, output_node): \"\"\" Calculate the equivalent resistance of a circuit represented as a graph. Parameters: - graph (nx.Graph): A networkx graph representing the circuit. Nodes are junctions, and edges are resistors with 'resistance' attribute. - input_node (str): The starting node for resistance calculation. - output_node (str): The ending node for resistance calculation. Returns: - float: The equivalent resistance between the input and output nodes. \"\"\" graph = graph.copy() # Operate on a copy to avoid modifying the original graph while len(graph.nodes) > 2: # Series Reduction for node in list(graph.nodes): # Iterate over a copy of the nodes if graph.degree(node) == 2: edges = list(graph.edges(node, data=True)) if len(edges) == 2: node1, node2, data1 = edges[0][0], edges[0][1], edges[0][2] node3, node4, data2 = edges[1][0], edges[1][1], edges[1][2] r1 = data1['resistance'] r2 = data2['resistance'] R_eq = r1 + r2 # Remove the series connection graph.remove_node(node) # Add the equivalent resistor new_node1 = node1 if node1 != node else node3 new_node2 = node2 if node2 != node else node4 graph.add_edge(new_node1, new_node2, resistance=R_eq) break # Break to restart the loop after modification # Parallel Reduction for node1 in list(graph.nodes): for node2 in list(graph.nodes): if node1 != node2 and graph.has_edge(node1, node2): edges_between = [(u, v, data) for u, v, data in graph.edges(data=True) if ((u == node1 and v == node2) or (u == node2 and v == node1))] if len(edges_between) > 1: R_eq = (sum(1 / data['resistance'] for u, v, data in edges_between))**(-1) # Remove parallel resistors edges_to_remove = [(u, v) for u, v, data in edges_between] for u, v in edges_to_remove: graph.remove_edge(u, v) # Add the equivalent resistor graph.add_edge(node1, node2, resistance=R_eq) break # Break to restart the loop after modification # Return the final equivalent resistance for u, v, data in graph.edges(data=True): return data['resistance'] return 0 # If no resistance is found def visualize_circuit(graph, title=\"Circuit Diagram\", pos=None): \"\"\" Visualizes the circuit graph using matplotlib. \"\"\" if pos is None: pos = nx.spring_layout(graph) # You can use other layout algorithms plt.figure(figsize=(10, 8)) # Adjust figure size for better visualization nx.draw(graph, pos, with_labels=True, node_color='skyblue', node_size=800, font_size=12, font_weight='bold', edgecolors='gray', linewidths=0.5) # Added edgecolors for better node visibility edge_labels = nx.get_edge_attributes(graph, 'resistance') nx.draw_networkx_edge_labels(graph, pos, edge_labels=edge_labels, font_size=10, bbox=dict(alpha=0.7, edgecolor=\"none\")) # Added bbox for label readability plt.title(title, fontsize=16) # Increased title font size plt.box(False) # Remove the surrounding box plt.show() return pos # Return the layout for consistent visualization def simulate_circuit(graph, input_node, output_node, voltage_source): # Create the admittance matrix and source vector num_nodes = len(graph.nodes) node_index = {node: i for i, node in enumerate(graph.nodes)} Y = np.zeros((num_nodes, num_nodes)) I = np.zeros(num_nodes) # Fill the admittance matrix for u, v, data in graph.edges(data=True): r = data['resistance'] g = 1 / r # Conductance i = node_index[u] j = node_index[v] Y[i, i] += g Y[j, j] += g Y[i, j] -= g Y[j, i] -= g # Add the voltage source input_index = node_index[input_node] output_index = node_index[output_node] Y[input_index, :] = 0 Y[output_index, :] = 0 Y[input_index, input_index] = 1 Y[output_index, output_index] = 1 I[input_index] = voltage_source I[output_index] = 0 # Solve for node voltages try: V = np.linalg.solve(Y, I) except np.linalg.LinAlgError: print(\"Singular matrix! Check your circuit configuration.\") return None node_voltages = {node: V[i] for node, i in node_index.items()} # Calculate edge currents edge_currents = {} for u, v, data in graph.edges(data=True): r = data['resistance'] V_u = node_voltages[u] V_v = node_voltages[v] I_uv = (V_u - V_v) / r edge_currents[(u, v)] = I_uv return node_voltages, edge_currents def display_simulation_results(graph, node_voltages, edge_currents, pos): if node_voltages is None: return plt.figure(figsize=(12, 10)) nx.draw(graph, pos, with_labels=True, node_color='skyblue', node_size=800, font_size=12, font_weight='bold', edgecolors='gray', linewidths=0.5) # Display resistance values edge_labels_resistance = nx.get_edge_attributes(graph, 'resistance') nx.draw_networkx_edge_labels(graph, pos, edge_labels=edge_labels_resistance, font_size=8, bbox=dict(alpha=0.7, edgecolor=\"none\")) # Display voltage values node_labels_voltage = {node: f\"{voltage:.2f}V\" for node, voltage in node_voltages.items()} nx.draw_networkx_labels(graph, pos, labels=node_labels_voltage, font_size=8, font_color='green', bbox=dict(alpha=0.7, edgecolor=\"none\")) # Display current values edge_labels_current = {edge: f\"{current:.2f}A\" for edge, current in edge_currents.items()} nx.draw_networkx_edge_labels(graph, pos, edge_labels=edge_labels_current, font_size=8, font_color='red', bbox=dict(alpha=0.7, edgecolor=\"none\"), label_pos=0.7) # Adjust label_pos for better placement plt.title(\"Circuit Simulation Results\", fontsize=16) plt.box(False) plt.show() # Example 1: Simple Series and Parallel Combination graph1 = nx.Graph() graph1.add_edge('A', 'B', resistance=10) graph1.add_edge('B', 'C', resistance=20) graph1.add_edge('A', 'C', resistance=30) pos1 = visualize_circuit(graph1, title=\"Example 1: Simple Series and Parallel\") R_eq1 = calculate_equivalent_resistance(graph1, 'A', 'C') print(f\"Equivalent Resistance for Example 1: {R_eq1:.2f} ohms\") node_voltages1, edge_currents1 = simulate_circuit(graph1, 'A', 'C', 12) if node_voltages1: display_simulation_results(graph1, node_voltages1, edge_currents1, pos1) # Example 2: Nested Configuration graph2 = nx.Graph() graph2.add_edge('A', 'B', resistance=10) graph2.add_edge('B', 'C', resistance=20) graph2.add_edge('A', 'D', resistance=30) graph2.add_edge('D', 'C', resistance=40) pos2 = visualize_circuit(graph2, title=\"Example 2: Nested Configuration\") R_eq2 = calculate_equivalent_resistance(graph2, 'A', 'C') print(f\"Equivalent Resistance for Example 2: {R_eq2:.2f} ohms\") node_voltages2, edge_currents2 = simulate_circuit(graph2, 'A', 'C', 12) if node_voltages2: display_simulation_results(graph2, node_voltages2, edge_currents2, pos2) # Example 3: Complex Graph with Multiple Cycles graph3 = nx.Graph() graph3.add_edge('A', 'B', resistance=10) graph3.add_edge('B', 'C', resistance=20) graph3.add_edge('C', 'D', resistance=30) graph3.add_edge('D', 'A', resistance=40) graph3.add_edge('A', 'C', resistance=50) pos3 = visualize_circuit(graph3, title=\"Example 3: Complex Graph with Multiple Cycles\") R_eq3 = calculate_equivalent_resistance(graph3, 'A', 'D') print(f\"Equivalent Resistance for Example 3: {R_eq3:.2f} ohms\") node_voltages3, edge_currents3 = simulate_circuit(graph3, 'A', 'D', 12) if node_voltages3: display_simulation_results(graph3, node_voltages3, edge_currents3, pos3)","title":"Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Central Limit Theorem: Theoretical Foundations and Empirical Verification 1. Introduction and Fundamental Concepts 1.1 Core Principle The Central Limit Theorem (CLT) establishes that the sampling distribution of the mean will approximate a normal distribution as sample size increases, regardless of the population's original distribution shape. 1.2 Mathematical Formulation \\[ \\frac{\\overline{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} N(0,1) \\quad \\text{as} \\quad n \\to \\infty \\] 1.3 Key Implications Applies to both normal and non-normal populations Enables reliable statistical inference Forms foundation for confidence intervals and hypothesis tests Standard error decreases as SE = \u03c3/\u221an 2. Theoretical Foundations 2.1 Historical Development 1733: Initial concepts by Abraham de Moivre 1812: Formalization by Pierre-Simon Laplace 1901: Rigorous proof by Aleksandr Lyapunov 2.2 Critical Assumptions Independence : Random sampling Identical Distribution : i.i.d. variables Finite Variance : \u03c3\u00b2 < \u221e 2.3 Convergence Properties Berry-Esseen Theorem quantifies convergence rate: $$ \\sup_x |F_n(x) - \u03a6(x)| \u2264 \\frac{C\u03c1}{\u03c3^3\\sqrt{n}} $$ where \u03c1 = E[|X-\u03bc|\u00b3] 3. Simulation Methodology 3.1 Python Implementation import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy.stats import norm def clt_demo(population, dist_name, sizes=[5, 10, 30, 50, 100], n_sim=10000): # Determine the number of rows and columns for subplots dynamically num_plots = len(sizes) rows = (num_plots + 2) // 3 fig, axs = plt.subplots(rows, 3, figsize=(15, 5 * rows)) axs = axs.flatten() for i, n in enumerate(sizes): # Generate sampling distribution of the mean means = [np.mean(np.random.choice(population, n, replace=True)) for _ in range(n_sim)] # Plot histogram of sample means sns.histplot(means, kde=True, ax=axs[i], stat='density', color='blue', label='Sample Means') # Overlay the theoretical normal distribution mu, se = np.mean(means), np.std(means) x = np.linspace(min(means), max(means), 100) axs[i].plot(x, norm.pdf(x, mu, se), 'r-', lw=2, label='Normal Approximation') # Add title and labels axs[i].set_title(f'Sample Size: n={n}\\nSE={se:.4f}') axs[i].legend() # Hide unused subplots for j in range(len(sizes), len(axs)): axs[j].axis('off') # Add a main title and adjust layout fig.suptitle(f'Central Limit Theorem Demonstration: {dist_name} Distribution', fontsize=16, y=0.95) plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show() 3.2 Test Distributions # Configuration np.random.seed(42) # Uniform Distribution U(0,1) uniform_pop = np.random.uniform(0, 1, 100000) clt_demo(uniform_pop, \"Uniform\") # Exponential Distribution (\u03bb=1) exp_pop = np.random.exponential(1, 100000) clt_demo(exp_pop, \"Exponential\") # Binomial Distribution (n=10, p=0.3) binom_pop = np.random.binomial(10, 0.3, 100000) clt_demo(binom_pop, \"Binomial\")","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#central-limit-theorem-theoretical-foundations-and-empirical-verification","text":"","title":"Central Limit Theorem: Theoretical Foundations and Empirical Verification"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-introduction-and-fundamental-concepts","text":"","title":"1. Introduction and Fundamental Concepts"},{"location":"1%20Physics/6%20Statistics/Problem_1/#11-core-principle","text":"The Central Limit Theorem (CLT) establishes that the sampling distribution of the mean will approximate a normal distribution as sample size increases, regardless of the population's original distribution shape.","title":"1.1 Core Principle"},{"location":"1%20Physics/6%20Statistics/Problem_1/#12-mathematical-formulation","text":"\\[ \\frac{\\overline{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} N(0,1) \\quad \\text{as} \\quad n \\to \\infty \\]","title":"1.2 Mathematical Formulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#13-key-implications","text":"Applies to both normal and non-normal populations Enables reliable statistical inference Forms foundation for confidence intervals and hypothesis tests Standard error decreases as SE = \u03c3/\u221an","title":"1.3 Key Implications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-theoretical-foundations","text":"","title":"2. Theoretical Foundations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#21-historical-development","text":"1733: Initial concepts by Abraham de Moivre 1812: Formalization by Pierre-Simon Laplace 1901: Rigorous proof by Aleksandr Lyapunov","title":"2.1 Historical Development"},{"location":"1%20Physics/6%20Statistics/Problem_1/#22-critical-assumptions","text":"Independence : Random sampling Identical Distribution : i.i.d. variables Finite Variance : \u03c3\u00b2 < \u221e","title":"2.2 Critical Assumptions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#23-convergence-properties","text":"Berry-Esseen Theorem quantifies convergence rate: $$ \\sup_x |F_n(x) - \u03a6(x)| \u2264 \\frac{C\u03c1}{\u03c3^3\\sqrt{n}} $$ where \u03c1 = E[|X-\u03bc|\u00b3]","title":"2.3 Convergence Properties"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-simulation-methodology","text":"","title":"3. Simulation Methodology"},{"location":"1%20Physics/6%20Statistics/Problem_1/#31-python-implementation","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy.stats import norm def clt_demo(population, dist_name, sizes=[5, 10, 30, 50, 100], n_sim=10000): # Determine the number of rows and columns for subplots dynamically num_plots = len(sizes) rows = (num_plots + 2) // 3 fig, axs = plt.subplots(rows, 3, figsize=(15, 5 * rows)) axs = axs.flatten() for i, n in enumerate(sizes): # Generate sampling distribution of the mean means = [np.mean(np.random.choice(population, n, replace=True)) for _ in range(n_sim)] # Plot histogram of sample means sns.histplot(means, kde=True, ax=axs[i], stat='density', color='blue', label='Sample Means') # Overlay the theoretical normal distribution mu, se = np.mean(means), np.std(means) x = np.linspace(min(means), max(means), 100) axs[i].plot(x, norm.pdf(x, mu, se), 'r-', lw=2, label='Normal Approximation') # Add title and labels axs[i].set_title(f'Sample Size: n={n}\\nSE={se:.4f}') axs[i].legend() # Hide unused subplots for j in range(len(sizes), len(axs)): axs[j].axis('off') # Add a main title and adjust layout fig.suptitle(f'Central Limit Theorem Demonstration: {dist_name} Distribution', fontsize=16, y=0.95) plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show()","title":"3.1 Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#32-test-distributions","text":"# Configuration np.random.seed(42) # Uniform Distribution U(0,1) uniform_pop = np.random.uniform(0, 1, 100000) clt_demo(uniform_pop, \"Uniform\") # Exponential Distribution (\u03bb=1) exp_pop = np.random.exponential(1, 100000) clt_demo(exp_pop, \"Exponential\") # Binomial Distribution (n=10, p=0.3) binom_pop = np.random.binomial(10, 0.3, 100000) clt_demo(binom_pop, \"Binomial\")","title":"3.2 Test Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \u03c0 Using Monte Carlo Methods Introduction Monte Carlo methods are a class of computational algorithms that rely on repeated random sampling to obtain numerical results. In this article, we'll explore two fascinating ways to estimate the value of \u03c0 using these methods: the circle-based approach and Buffon's Needle experiment. Estimating \u03c0 Using a Unit Circle Theoretical Foundation Imagine a unit circle (radius = 1) inscribed inside a square with side length 2. The area of the circle is: \\[ \\text{Area of Circle} = \\pi r^2 = \\pi (1)^2 = \\pi \\] The area of the square is: \\[ \\text{Area of Square} = (\\text{side length})^2 = 2^2 = 4 \\] If we randomly scatter points inside the square, the probability that a point falls inside the circle is the ratio of their areas: \\[ P(\\text{point inside circle}) = \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4} \\] Rearranging this gives us our estimation formula: \\[ \\pi \\approx 4 \\times \\frac{\\text{Number of points inside circle}}{\\text{Total number of points}} \\] Python Implementation import numpy as np import matplotlib.pyplot as plt # Generate random points in [-1,1] x [-1,1] n_points = 10000 points = np.random.uniform(-1, 1, (n_points, 2)) # Calculate distances from origin distances = np.sqrt(points[:, 0]**2 + points[:, 1]**2) # Count points inside circle inside = np.sum(distances <= 1) # Estimate \u03c0 pi_estimate = 4 * inside / n_points print(f\"Estimated \u03c0: {pi_estimate}\") Visualization import numpy as np import matplotlib.pyplot as plt # Generate random points in [-1,1] x [-1,1] n_points = 10000 points = np.random.uniform(-1, 1, (n_points, 2)) distances = np.sqrt(points[:, 0]**2 + points[:, 1]**2) # Separate points inside and outside the circle inside = distances <= 1 outside = ~inside # Plot points plt.figure(figsize=(8, 8)) plt.scatter(points[inside, 0], points[inside, 1], color='blue', s=1, alpha=0.5) plt.scatter(points[outside, 0], points[outside, 1], color='red', s=1, alpha=0.5) # Draw circle theta = np.linspace(0, 2 * np.pi, 100) plt.plot(np.cos(theta), np.sin(theta), color='green', linewidth=2) plt.axis('equal') plt.title(f\"Monte Carlo Estimation of \u03c0 (n={n_points})\") plt.show() Analysis of Convergence import numpy as np import matplotlib.pyplot as plt # Convergence analysis max_points = 10000 step = 100 point_counts = range(1, max_points + 1, step) estimates = [] for n in point_counts: points = np.random.uniform(-1, 1, (n, 2)) distances = np.sqrt(points[:, 0]**2 + points[:, 1]**2) inside = np.sum(distances <= 1) pi_estimate = 4 * inside / n estimates.append(pi_estimate) # Plot convergence plt.figure(figsize=(10, 6)) plt.plot(point_counts, estimates, label='Estimate') plt.axhline(np.pi, color='r', linestyle='--', label='True \u03c0') plt.xlabel('Number of points') plt.ylabel('\u03c0 Estimate') plt.title('Convergence of \u03c0 Estimation') plt.legend() plt.grid() plt.show() Part 2: Estimating \u03c0 Using Buffon's Needle Theoretical Foundation Buffon's Needle is one of the oldest problems in geometric probability. Imagine a needle of length \\( L \\) dropped onto a floor with parallel lines distance \\( D \\) apart (where \\(L \\leq D\\) ). The probability that the needle crosses a line is: \\[ P(\\text{cross}) = \\frac{2L}{\\pi D} \\] Rearranging gives us: \\[ \\pi = \\frac{2L}{P(\\text{cross}) \\cdot D} \\] For simplicity, we'll use \\( L = D = 1 \\) , giving: \\[ \\pi \\approx \\frac{2}{\\text{Observed crossing probability}} \\] Python Implementation import numpy as np n_drops = 100000 needle_length = 1 line_distance = 1 # Random position of needle center (0 to D) centers = np.random.uniform(0, line_distance, n_drops) # Random angle (0 to \u03c0/2 is sufficient) angles = np.random.uniform(0, np.pi / 2, n_drops) # Calculate if needle crosses crosses = (centers <= (needle_length / 2) * np.sin(angles)) | \\ (centers >= line_distance - (needle_length / 2) * np.sin(angles)) crossing_prob = np.mean(crosses) pi_estimate = (2 * needle_length) / (crossing_prob * line_distance) if crossing_prob > 0 else 0 print(f\"Estimated \u03c0: {pi_estimate}\") Visualization # Plot Buffon's Needle simulation n_drops = 50 centers = np.random.uniform(0, line_distance, n_drops) angles = np.random.uniform(0, np.pi, n_drops) # Calculate endpoints x1 = centers - (needle_length / 2) * np.cos(angles) x2 = centers + (needle_length / 2) * np.cos(angles) y1 = (needle_length / 2) * np.sin(angles) y2 = -(needle_length / 2) * np.sin(angles) plt.figure(figsize=(10, 5)) # Draw lines for i in range(0, int(line_distance) + 1): plt.axvline(i, color='black') # Draw needles for i in range(n_drops): crosses = (centers[i] <= (needle_length / 2) * np.sin(angles[i])) or \\ (centers[i] >= line_distance - (needle_length / 2) * np.sin(angles[i])) color = 'red' if crosses else 'blue' plt.plot([x1[i], x2[i]], [y1[i], y2[i]], color=color, alpha=0.7) plt.title(\"Buffon's Needle Simulation\") plt.axis('equal') plt.ylim(-1, 1) plt.show() Analysis of Convergence # Convergence analysis for Buffon's Needle max_drops = 10000 step = 100 drop_counts = range(1, max_drops + 1, step) estimates = [] for n in drop_counts: centers = np.random.uniform(0, line_distance, n) angles = np.random.uniform(0, np.pi / 2, n) crosses = (centers <= (needle_length / 2) * np.sin(angles)) | \\ (centers >= line_distance - (needle_length / 2) * np.sin(angles)) crossing_prob = np.mean(crosses) pi_estimate = (2 * needle_length) / (crossing_prob * line_distance) if crossing_prob > 0 else 0 estimates.append(pi_estimate) plt.figure(figsize=(10, 6)) plt.plot(drop_counts, estimates, label='Estimate') plt.axhline(np.pi, color='r', linestyle='--', label='True \u03c0') plt.xlabel('Number of needle drops') plt.ylabel('\u03c0 Estimate') plt.title(\"Convergence of Buffon's Needle\") plt.legend() plt.grid() plt.show() Method Comparison Aspect Circle Method Buffon's Needle Convergence Rate ~1/\u221an ~1/\u221an (but slower) Computational Cost Low (simple math) Higher (trig functions) Implementation Simple More complex Historical Context Modern Monte Carlo 18th century problem Visual Appeal High Moderate","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#introduction","text":"Monte Carlo methods are a class of computational algorithms that rely on repeated random sampling to obtain numerical results. In this article, we'll explore two fascinating ways to estimate the value of \u03c0 using these methods: the circle-based approach and Buffon's Needle experiment.","title":"Introduction"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-a-unit-circle","text":"","title":"Estimating \u03c0 Using a Unit Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"Imagine a unit circle (radius = 1) inscribed inside a square with side length 2. The area of the circle is: \\[ \\text{Area of Circle} = \\pi r^2 = \\pi (1)^2 = \\pi \\] The area of the square is: \\[ \\text{Area of Square} = (\\text{side length})^2 = 2^2 = 4 \\] If we randomly scatter points inside the square, the probability that a point falls inside the circle is the ratio of their areas: \\[ P(\\text{point inside circle}) = \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4} \\] Rearranging this gives us our estimation formula: \\[ \\pi \\approx 4 \\times \\frac{\\text{Number of points inside circle}}{\\text{Total number of points}} \\]","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Generate random points in [-1,1] x [-1,1] n_points = 10000 points = np.random.uniform(-1, 1, (n_points, 2)) # Calculate distances from origin distances = np.sqrt(points[:, 0]**2 + points[:, 1]**2) # Count points inside circle inside = np.sum(distances <= 1) # Estimate \u03c0 pi_estimate = 4 * inside / n_points print(f\"Estimated \u03c0: {pi_estimate}\")","title":"Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization","text":"import numpy as np import matplotlib.pyplot as plt # Generate random points in [-1,1] x [-1,1] n_points = 10000 points = np.random.uniform(-1, 1, (n_points, 2)) distances = np.sqrt(points[:, 0]**2 + points[:, 1]**2) # Separate points inside and outside the circle inside = distances <= 1 outside = ~inside # Plot points plt.figure(figsize=(8, 8)) plt.scatter(points[inside, 0], points[inside, 1], color='blue', s=1, alpha=0.5) plt.scatter(points[outside, 0], points[outside, 1], color='red', s=1, alpha=0.5) # Draw circle theta = np.linspace(0, 2 * np.pi, 100) plt.plot(np.cos(theta), np.sin(theta), color='green', linewidth=2) plt.axis('equal') plt.title(f\"Monte Carlo Estimation of \u03c0 (n={n_points})\") plt.show()","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#analysis-of-convergence","text":"import numpy as np import matplotlib.pyplot as plt # Convergence analysis max_points = 10000 step = 100 point_counts = range(1, max_points + 1, step) estimates = [] for n in point_counts: points = np.random.uniform(-1, 1, (n, 2)) distances = np.sqrt(points[:, 0]**2 + points[:, 1]**2) inside = np.sum(distances <= 1) pi_estimate = 4 * inside / n estimates.append(pi_estimate) # Plot convergence plt.figure(figsize=(10, 6)) plt.plot(point_counts, estimates, label='Estimate') plt.axhline(np.pi, color='r', linestyle='--', label='True \u03c0') plt.xlabel('Number of points') plt.ylabel('\u03c0 Estimate') plt.title('Convergence of \u03c0 Estimation') plt.legend() plt.grid() plt.show()","title":"Analysis of Convergence"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"Part 2: Estimating \u03c0 Using Buffon's Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation_1","text":"Buffon's Needle is one of the oldest problems in geometric probability. Imagine a needle of length \\( L \\) dropped onto a floor with parallel lines distance \\( D \\) apart (where \\(L \\leq D\\) ). The probability that the needle crosses a line is: \\[ P(\\text{cross}) = \\frac{2L}{\\pi D} \\] Rearranging gives us: \\[ \\pi = \\frac{2L}{P(\\text{cross}) \\cdot D} \\] For simplicity, we'll use \\( L = D = 1 \\) , giving: \\[ \\pi \\approx \\frac{2}{\\text{Observed crossing probability}} \\]","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-implementation_1","text":"import numpy as np n_drops = 100000 needle_length = 1 line_distance = 1 # Random position of needle center (0 to D) centers = np.random.uniform(0, line_distance, n_drops) # Random angle (0 to \u03c0/2 is sufficient) angles = np.random.uniform(0, np.pi / 2, n_drops) # Calculate if needle crosses crosses = (centers <= (needle_length / 2) * np.sin(angles)) | \\ (centers >= line_distance - (needle_length / 2) * np.sin(angles)) crossing_prob = np.mean(crosses) pi_estimate = (2 * needle_length) / (crossing_prob * line_distance) if crossing_prob > 0 else 0 print(f\"Estimated \u03c0: {pi_estimate}\")","title":"Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization_1","text":"# Plot Buffon's Needle simulation n_drops = 50 centers = np.random.uniform(0, line_distance, n_drops) angles = np.random.uniform(0, np.pi, n_drops) # Calculate endpoints x1 = centers - (needle_length / 2) * np.cos(angles) x2 = centers + (needle_length / 2) * np.cos(angles) y1 = (needle_length / 2) * np.sin(angles) y2 = -(needle_length / 2) * np.sin(angles) plt.figure(figsize=(10, 5)) # Draw lines for i in range(0, int(line_distance) + 1): plt.axvline(i, color='black') # Draw needles for i in range(n_drops): crosses = (centers[i] <= (needle_length / 2) * np.sin(angles[i])) or \\ (centers[i] >= line_distance - (needle_length / 2) * np.sin(angles[i])) color = 'red' if crosses else 'blue' plt.plot([x1[i], x2[i]], [y1[i], y2[i]], color=color, alpha=0.7) plt.title(\"Buffon's Needle Simulation\") plt.axis('equal') plt.ylim(-1, 1) plt.show()","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#analysis-of-convergence_1","text":"# Convergence analysis for Buffon's Needle max_drops = 10000 step = 100 drop_counts = range(1, max_drops + 1, step) estimates = [] for n in drop_counts: centers = np.random.uniform(0, line_distance, n) angles = np.random.uniform(0, np.pi / 2, n) crosses = (centers <= (needle_length / 2) * np.sin(angles)) | \\ (centers >= line_distance - (needle_length / 2) * np.sin(angles)) crossing_prob = np.mean(crosses) pi_estimate = (2 * needle_length) / (crossing_prob * line_distance) if crossing_prob > 0 else 0 estimates.append(pi_estimate) plt.figure(figsize=(10, 6)) plt.plot(drop_counts, estimates, label='Estimate') plt.axhline(np.pi, color='r', linestyle='--', label='True \u03c0') plt.xlabel('Number of needle drops') plt.ylabel('\u03c0 Estimate') plt.title(\"Convergence of Buffon's Needle\") plt.legend() plt.grid() plt.show()","title":"Analysis of Convergence"},{"location":"1%20Physics/6%20Statistics/Problem_2/#method-comparison","text":"Aspect Circle Method Buffon's Needle Convergence Rate ~1/\u221an ~1/\u221an (but slower) Computational Cost Low (simple math) Higher (trig functions) Implementation Simple More complex Historical Context Modern Monte Carlo 18th century problem Visual Appeal High Moderate","title":"Method Comparison"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measurements and Uncertainties: Fundamental Physics and Mathematical Approaches Introduction In physics and other scientific disciplines, measurements are the building blocks of our understanding of nature. However, no measurement is perfect - every measurement contains some uncertainty. Understanding the sources of these uncertainties is vital for correctly interpreting measurements and reliably presenting results. This document examines the fundamentals of measurement uncertainties, their types, mathematical models, and simulation methods. 1. What is Measurement Uncertainty? Measurement uncertainty is a measure of how much a measurement might deviate from the true value. No measuring instrument is perfect, and every measurement process contains various sources of error. Example : Let's imagine measuring the length of a pencil with a ruler. If the smallest division on the ruler is 1 mm, the uncertainty of our measurement will be approximately \u00b10.5 mm. 2. Types of Uncertainties 2.1 Systematic Errors Systematic errors are consistent biases that affect measurements in the same direction: Instrument error : Comes from calibration issues Method error : Results from flaws in the measurement technique Environmental factors : Temperature, humidity, etc. import numpy as np import matplotlib.pyplot as plt # Systematic error simulation true_value = 10.0 systematic_error = 0.5 # Constant +0.5 error measurements = np.random.normal(0, 0.2, 100) + true_value + systematic_error plt.figure(figsize=(8, 5)) plt.hist(measurements, bins=20) plt.axvline(x=true_value, color='r', linestyle='--', label='True Value') plt.axvline(x=np.mean(measurements), color='g', linestyle='--', label='Measurement Mean') plt.xlabel('Measurement Value') plt.ylabel('Frequency') plt.legend() plt.title('Effect of Systematic Error') plt.show() 2.2 Random Errors Random errors are unpredictable fluctuations that vary between measurements: Observer error : Small differences from the person taking measurements Instrument precision : Natural fluctuations of measuring devices Environmental noise : Uncontrollable external factors import numpy as np import matplotlib.pyplot as plt # Random error simulation true_value = 10.0 random_errors = np.random.normal(0, 0.5, 100) # Mean 0, std dev 0.5 random_measurements = true_value + random_errors plt.figure(figsize=(8, 5)) plt.hist(random_measurements, bins=20) plt.axvline(x=true_value, color='r', linestyle='--', label='True Value') plt.axvline(x=np.mean(random_measurements), color='g', linestyle='--', label='Measurement Mean') plt.xlabel('Measurement Value') plt.ylabel('Frequency') plt.legend() plt.title('Effect of Random Error') plt.show() 3. Mathematical Representation of Uncertainties 3.1 Absolute and Relative Uncertainty Absolute uncertainty (\u0394x) : Absolute value of potential deviation from true value Example: 15.2 \u00b1 0.3 cm \u2192 \u0394x = 0.3 cm Relative uncertainty : Ratio of absolute uncertainty to measured value Relative uncertainty = \u0394x / x Example: 0.3 / 15.2 \u2248 0.02 or 2% # Relative uncertainty calculation import numpy as np measurement = 15.2 absolute_uncertainty = 0.3 relative_uncertainty = absolute_uncertainty / measurement print(f\"Absolute uncertainty: {absolute_uncertainty}\") print(f\"Relative uncertainty: {relative_uncertainty:.4f} or {relative_uncertainty*100:.2f}%\") 3.2 Standard Deviation and Standard Error Standard deviation (\u03c3) : Measure of how spread out data points are Standard error (SE) : Uncertainty of the mean, SE = \u03c3/\u221an import numpy as np # Standard deviation and error calculation data = np.array([9.8, 10.2, 10.0, 9.9, 10.1, 9.7, 10.3, 10.0, 9.8, 10.2]) mean = np.mean(data) std_dev = np.std(data, ddof=1) # ddof=1 for sample standard deviation std_error = std_dev / np.sqrt(len(data)) print(f\"Mean: {mean:.2f}\") print(f\"Standard deviation: {std_dev:.4f}\") print(f\"Standard error: {std_error:.4f}\") 4. Propagation of Uncertainties 4.1 Addition/Subtraction Operations Absolute uncertainties combine as root sum of squares: \u0394z = \u221a(\u0394x\u00b2 + \u0394y\u00b2) 4.2 Multiplication/Division Operations Relative uncertainties combine as root sum of squares: \u0394z/z = \u221a((\u0394x/x)\u00b2 + (\u0394y/y)\u00b2) import numpy as np # Uncertainty propagation calculation x, dx = 10.0, 0.2 y, dy = 5.0, 0.1 # Addition z_sum = x + y dz_sum = np.sqrt(dx**2 + dy**2) # Multiplication z_prod = x * y dz_prod = z_prod * np.sqrt((dx/x)**2 + (dy/y)**2) print(f\"Sum: {z_sum:.2f} \u00b1 {dz_sum:.2f}\") print(f\"Product: {z_prod:.2f} \u00b1 {dz_prod:.2f}\") 5. Graphical Representation of Uncertainties 5.1 Error Bars import numpy as np import matplotlib.pyplot as plt # Error bar example x_data = np.array([1, 2, 3, 4, 5]) y_data = np.array([2.1, 3.9, 6.2, 8.1, 9.8]) y_error = np.array([0.3, 0.4, 0.2, 0.5, 0.3]) plt.figure(figsize=(8, 5)) plt.errorbar(x_data, y_data, yerr=y_error, fmt='o', capsize=5) plt.xlabel('X Values') plt.ylabel('Y Values') plt.title('Measurement Graph with Error Bars') plt.grid(True) plt.show() 5.2 Confidence Intervals import numpy as np import matplotlib.pyplot as plt # Confidence interval simulation np.random.seed(42) data = np.random.normal(50, 5, 100) # Mean 50, std dev 5 mean = np.mean(data) std_error = np.std(data, ddof=1) / np.sqrt(len(data)) confidence_interval = 1.96 * std_error # 95% confidence print(f\"Mean: {mean:.2f}\") print(f\"95% Confidence Interval: {mean:.2f} \u00b1 {confidence_interval:.2f}\") plt.figure(figsize=(8, 5)) plt.hist(data, bins=20, alpha=0.7) plt.axvline(x=mean, color='r', label='Mean') plt.axvline(x=mean - confidence_interval, color='g', linestyle='--', label='Confidence Interval') plt.axvline(x=mean + confidence_interval, color='g', linestyle='--') plt.legend() plt.title('Measurement Distribution and Confidence Interval') plt.show() 6. Reporting Measurement Uncertainties In scientific work, measurement results are typically reported as: Significant figures rule : Uncertainty given with at most 2 significant figures Rounding : Measurement value rounded to match uncertainty precision Units : Both measurement and uncertainty have same units Correct examples : - (15.24 \u00b1 0.05) cm - (1.057 \u00b1 0.003) g Incorrect examples : - 15.235 \u00b1 0.05 cm (measurement too precise) - 15.2 \u00b1 0.053 cm (uncertainty too precise) 7. Monte Carlo Simulation for Uncertainty Analysis import numpy as np import matplotlib.pyplot as plt # Monte Carlo simulation for uncertainty analysis def model_calculation(a, b): return a * np.exp(-b) # True parameters a_true, b_true = 2.0, 0.5 # Measurement uncertainties a_meas, a_unc = 2.1, 0.1 b_meas, b_unc = 0.52, 0.02 # Monte Carlo simulation n_simulations = 10000 a_sim = np.random.normal(a_meas, a_unc, n_simulations) b_sim = np.random.normal(b_meas, b_unc, n_simulations) results = model_calculation(a_sim, b_sim) # Analysis mean_result = np.mean(results) std_result = np.std(results) conf_interval = np.percentile(results, [2.5, 97.5]) # 95% CI print(f\"Model output mean: {mean_result:.4f}\") print(f\"Standard deviation: {std_result:.4f}\") print(f\"95% confidence interval: [{conf_interval[0]:.4f}, {conf_interval[1]:.4f}]\") # Histogram plt.figure(figsize=(8, 5)) plt.hist(results, bins=50, density=True, alpha=0.7) plt.axvline(x=mean_result, color='r', label='Mean') plt.axvline(x=conf_interval[0], color='g', linestyle='--', label='95% CI') plt.axvline(x=conf_interval[1], color='g', linestyle='--') plt.xlabel('Model Output') plt.ylabel('Probability Density') plt.title('Uncertainty Analysis with Monte Carlo Simulation') plt.legend() plt.show()","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measurements-and-uncertainties-fundamental-physics-and-mathematical-approaches","text":"","title":"Measurements and Uncertainties: Fundamental Physics and Mathematical Approaches"},{"location":"1%20Physics/7%20Measurements/Problem_1/#introduction","text":"In physics and other scientific disciplines, measurements are the building blocks of our understanding of nature. However, no measurement is perfect - every measurement contains some uncertainty. Understanding the sources of these uncertainties is vital for correctly interpreting measurements and reliably presenting results. This document examines the fundamentals of measurement uncertainties, their types, mathematical models, and simulation methods.","title":"Introduction"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-what-is-measurement-uncertainty","text":"Measurement uncertainty is a measure of how much a measurement might deviate from the true value. No measuring instrument is perfect, and every measurement process contains various sources of error. Example : Let's imagine measuring the length of a pencil with a ruler. If the smallest division on the ruler is 1 mm, the uncertainty of our measurement will be approximately \u00b10.5 mm.","title":"1. What is Measurement Uncertainty?"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-types-of-uncertainties","text":"","title":"2. Types of Uncertainties"},{"location":"1%20Physics/7%20Measurements/Problem_1/#21-systematic-errors","text":"Systematic errors are consistent biases that affect measurements in the same direction: Instrument error : Comes from calibration issues Method error : Results from flaws in the measurement technique Environmental factors : Temperature, humidity, etc. import numpy as np import matplotlib.pyplot as plt # Systematic error simulation true_value = 10.0 systematic_error = 0.5 # Constant +0.5 error measurements = np.random.normal(0, 0.2, 100) + true_value + systematic_error plt.figure(figsize=(8, 5)) plt.hist(measurements, bins=20) plt.axvline(x=true_value, color='r', linestyle='--', label='True Value') plt.axvline(x=np.mean(measurements), color='g', linestyle='--', label='Measurement Mean') plt.xlabel('Measurement Value') plt.ylabel('Frequency') plt.legend() plt.title('Effect of Systematic Error') plt.show()","title":"2.1 Systematic Errors"},{"location":"1%20Physics/7%20Measurements/Problem_1/#22-random-errors","text":"Random errors are unpredictable fluctuations that vary between measurements: Observer error : Small differences from the person taking measurements Instrument precision : Natural fluctuations of measuring devices Environmental noise : Uncontrollable external factors import numpy as np import matplotlib.pyplot as plt # Random error simulation true_value = 10.0 random_errors = np.random.normal(0, 0.5, 100) # Mean 0, std dev 0.5 random_measurements = true_value + random_errors plt.figure(figsize=(8, 5)) plt.hist(random_measurements, bins=20) plt.axvline(x=true_value, color='r', linestyle='--', label='True Value') plt.axvline(x=np.mean(random_measurements), color='g', linestyle='--', label='Measurement Mean') plt.xlabel('Measurement Value') plt.ylabel('Frequency') plt.legend() plt.title('Effect of Random Error') plt.show()","title":"2.2 Random Errors"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-mathematical-representation-of-uncertainties","text":"","title":"3. Mathematical Representation of Uncertainties"},{"location":"1%20Physics/7%20Measurements/Problem_1/#31-absolute-and-relative-uncertainty","text":"Absolute uncertainty (\u0394x) : Absolute value of potential deviation from true value Example: 15.2 \u00b1 0.3 cm \u2192 \u0394x = 0.3 cm Relative uncertainty : Ratio of absolute uncertainty to measured value Relative uncertainty = \u0394x / x Example: 0.3 / 15.2 \u2248 0.02 or 2% # Relative uncertainty calculation import numpy as np measurement = 15.2 absolute_uncertainty = 0.3 relative_uncertainty = absolute_uncertainty / measurement print(f\"Absolute uncertainty: {absolute_uncertainty}\") print(f\"Relative uncertainty: {relative_uncertainty:.4f} or {relative_uncertainty*100:.2f}%\")","title":"3.1 Absolute and Relative Uncertainty"},{"location":"1%20Physics/7%20Measurements/Problem_1/#32-standard-deviation-and-standard-error","text":"Standard deviation (\u03c3) : Measure of how spread out data points are Standard error (SE) : Uncertainty of the mean, SE = \u03c3/\u221an import numpy as np # Standard deviation and error calculation data = np.array([9.8, 10.2, 10.0, 9.9, 10.1, 9.7, 10.3, 10.0, 9.8, 10.2]) mean = np.mean(data) std_dev = np.std(data, ddof=1) # ddof=1 for sample standard deviation std_error = std_dev / np.sqrt(len(data)) print(f\"Mean: {mean:.2f}\") print(f\"Standard deviation: {std_dev:.4f}\") print(f\"Standard error: {std_error:.4f}\")","title":"3.2 Standard Deviation and Standard Error"},{"location":"1%20Physics/7%20Measurements/Problem_1/#4-propagation-of-uncertainties","text":"","title":"4. Propagation of Uncertainties"},{"location":"1%20Physics/7%20Measurements/Problem_1/#41-additionsubtraction-operations","text":"Absolute uncertainties combine as root sum of squares: \u0394z = \u221a(\u0394x\u00b2 + \u0394y\u00b2)","title":"4.1 Addition/Subtraction Operations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#42-multiplicationdivision-operations","text":"Relative uncertainties combine as root sum of squares: \u0394z/z = \u221a((\u0394x/x)\u00b2 + (\u0394y/y)\u00b2) import numpy as np # Uncertainty propagation calculation x, dx = 10.0, 0.2 y, dy = 5.0, 0.1 # Addition z_sum = x + y dz_sum = np.sqrt(dx**2 + dy**2) # Multiplication z_prod = x * y dz_prod = z_prod * np.sqrt((dx/x)**2 + (dy/y)**2) print(f\"Sum: {z_sum:.2f} \u00b1 {dz_sum:.2f}\") print(f\"Product: {z_prod:.2f} \u00b1 {dz_prod:.2f}\")","title":"4.2 Multiplication/Division Operations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#5-graphical-representation-of-uncertainties","text":"","title":"5. Graphical Representation of Uncertainties"},{"location":"1%20Physics/7%20Measurements/Problem_1/#51-error-bars","text":"import numpy as np import matplotlib.pyplot as plt # Error bar example x_data = np.array([1, 2, 3, 4, 5]) y_data = np.array([2.1, 3.9, 6.2, 8.1, 9.8]) y_error = np.array([0.3, 0.4, 0.2, 0.5, 0.3]) plt.figure(figsize=(8, 5)) plt.errorbar(x_data, y_data, yerr=y_error, fmt='o', capsize=5) plt.xlabel('X Values') plt.ylabel('Y Values') plt.title('Measurement Graph with Error Bars') plt.grid(True) plt.show()","title":"5.1 Error Bars"},{"location":"1%20Physics/7%20Measurements/Problem_1/#52-confidence-intervals","text":"import numpy as np import matplotlib.pyplot as plt # Confidence interval simulation np.random.seed(42) data = np.random.normal(50, 5, 100) # Mean 50, std dev 5 mean = np.mean(data) std_error = np.std(data, ddof=1) / np.sqrt(len(data)) confidence_interval = 1.96 * std_error # 95% confidence print(f\"Mean: {mean:.2f}\") print(f\"95% Confidence Interval: {mean:.2f} \u00b1 {confidence_interval:.2f}\") plt.figure(figsize=(8, 5)) plt.hist(data, bins=20, alpha=0.7) plt.axvline(x=mean, color='r', label='Mean') plt.axvline(x=mean - confidence_interval, color='g', linestyle='--', label='Confidence Interval') plt.axvline(x=mean + confidence_interval, color='g', linestyle='--') plt.legend() plt.title('Measurement Distribution and Confidence Interval') plt.show()","title":"5.2 Confidence Intervals"},{"location":"1%20Physics/7%20Measurements/Problem_1/#6-reporting-measurement-uncertainties","text":"In scientific work, measurement results are typically reported as: Significant figures rule : Uncertainty given with at most 2 significant figures Rounding : Measurement value rounded to match uncertainty precision Units : Both measurement and uncertainty have same units Correct examples : - (15.24 \u00b1 0.05) cm - (1.057 \u00b1 0.003) g Incorrect examples : - 15.235 \u00b1 0.05 cm (measurement too precise) - 15.2 \u00b1 0.053 cm (uncertainty too precise)","title":"6. Reporting Measurement Uncertainties"},{"location":"1%20Physics/7%20Measurements/Problem_1/#7-monte-carlo-simulation-for-uncertainty-analysis","text":"import numpy as np import matplotlib.pyplot as plt # Monte Carlo simulation for uncertainty analysis def model_calculation(a, b): return a * np.exp(-b) # True parameters a_true, b_true = 2.0, 0.5 # Measurement uncertainties a_meas, a_unc = 2.1, 0.1 b_meas, b_unc = 0.52, 0.02 # Monte Carlo simulation n_simulations = 10000 a_sim = np.random.normal(a_meas, a_unc, n_simulations) b_sim = np.random.normal(b_meas, b_unc, n_simulations) results = model_calculation(a_sim, b_sim) # Analysis mean_result = np.mean(results) std_result = np.std(results) conf_interval = np.percentile(results, [2.5, 97.5]) # 95% CI print(f\"Model output mean: {mean_result:.4f}\") print(f\"Standard deviation: {std_result:.4f}\") print(f\"95% confidence interval: [{conf_interval[0]:.4f}, {conf_interval[1]:.4f}]\") # Histogram plt.figure(figsize=(8, 5)) plt.hist(results, bins=50, density=True, alpha=0.7) plt.axvline(x=mean_result, color='r', label='Mean') plt.axvline(x=conf_interval[0], color='g', linestyle='--', label='95% CI') plt.axvline(x=conf_interval[1], color='g', linestyle='--') plt.xlabel('Model Output') plt.ylabel('Probability Density') plt.title('Uncertainty Analysis with Monte Carlo Simulation') plt.legend() plt.show()","title":"7. Monte Carlo Simulation for Uncertainty Analysis"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}